/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __ENDPOINT_SECURITY_INDIRECT__: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &[u8; 9] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &[u8; 6] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __VISIONOS_1_0: u32 = 10000;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140200;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const MACH_PORT_NULL: u32 = 0;
pub const MACH_PORT_TYPE_DNREQUEST: u32 = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: u32 = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: u32 = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: u32 = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: u32 = 1;
pub const MACH_PORT_QLIMIT_ZERO: u32 = 0;
pub const MACH_PORT_QLIMIT_BASIC: u32 = 5;
pub const MACH_PORT_QLIMIT_SMALL: u32 = 16;
pub const MACH_PORT_QLIMIT_LARGE: u32 = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: u32 = 65534;
pub const MACH_PORT_QLIMIT_MIN: u32 = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: u32 = 5;
pub const MACH_PORT_QLIMIT_MAX: u32 = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: u32 = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: u32 = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: u32 = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: u32 = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: u32 = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: u32 = 32;
pub const MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE: u32 = 64;
pub const MACH_PORT_STATUS_FLAG_NO_GRANT: u32 = 128;
pub const MACH_PORT_LIMITS_INFO: u32 = 1;
pub const MACH_PORT_RECEIVE_STATUS: u32 = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: u32 = 3;
pub const MACH_PORT_TEMPOWNER: u32 = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: u32 = 5;
pub const MACH_PORT_DENAP_RECEIVER: u32 = 6;
pub const MACH_PORT_INFO_EXT: u32 = 7;
pub const MACH_PORT_GUARD_INFO: u32 = 8;
pub const MACH_PORT_SERVICE_THROTTLED: u32 = 9;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: u32 = 1;
pub const MACH_PORT_SERVICE_THROTTLED_COUNT: u32 = 1;
pub const MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN: u32 = 255;
pub const MPO_CONTEXT_AS_GUARD: u32 = 1;
pub const MPO_QLIMIT: u32 = 2;
pub const MPO_TEMPOWNER: u32 = 4;
pub const MPO_IMPORTANCE_RECEIVER: u32 = 8;
pub const MPO_INSERT_SEND_RIGHT: u32 = 16;
pub const MPO_STRICT: u32 = 32;
pub const MPO_DENAP_RECEIVER: u32 = 64;
pub const MPO_IMMOVABLE_RECEIVE: u32 = 128;
pub const MPO_FILTER_MSG: u32 = 256;
pub const MPO_TG_BLOCK_TRACKING: u32 = 512;
pub const MPO_SERVICE_PORT: u32 = 1024;
pub const MPO_CONNECTION_PORT: u32 = 2048;
pub const MPO_REPLY_PORT: u32 = 4096;
pub const MPO_ENFORCE_REPLY_PORT_SEMANTICS: u32 = 8192;
pub const MPO_PROVISIONAL_REPLY_PORT: u32 = 16384;
pub const MPO_PROVISIONAL_ID_PROT_OPTOUT: u32 = 32768;
pub const GUARD_TYPE_MACH_PORT: u32 = 1;
pub const MAX_FATAL_kGUARD_EXC_CODE: u32 = 128;
pub const MPG_FLAGS_NONE: u32 = 0;
pub const MAX_OPTIONAL_kGUARD_EXC_CODE: u32 = 524288;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP: u64 = 72057594037927936;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT: u64 = 144115188075855872;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER: u64 = 288230376151711744;
pub const MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR: u64 = 576460752303423488;
pub const MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA: u64 = 1152921504606846976;
pub const MPG_FLAGS_STRICT_REPLY_MASK: i64 = -72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DEALLOC: u64 = 72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DESTROY: u64 = 144115188075855872;
pub const MPG_FLAGS_MOD_REFS_PINNED_COPYIN: u64 = 288230376151711744;
pub const MPG_FLAGS_IMMOVABLE_PINNED: u64 = 72057594037927936;
pub const MPG_STRICT: u32 = 1;
pub const MPG_IMMOVABLE_RECEIVE: u32 = 2;
pub const KERN_SUCCESS: u32 = 0;
pub const KERN_INVALID_ADDRESS: u32 = 1;
pub const KERN_PROTECTION_FAILURE: u32 = 2;
pub const KERN_NO_SPACE: u32 = 3;
pub const KERN_INVALID_ARGUMENT: u32 = 4;
pub const KERN_FAILURE: u32 = 5;
pub const KERN_RESOURCE_SHORTAGE: u32 = 6;
pub const KERN_NOT_RECEIVER: u32 = 7;
pub const KERN_NO_ACCESS: u32 = 8;
pub const KERN_MEMORY_FAILURE: u32 = 9;
pub const KERN_MEMORY_ERROR: u32 = 10;
pub const KERN_ALREADY_IN_SET: u32 = 11;
pub const KERN_NOT_IN_SET: u32 = 12;
pub const KERN_NAME_EXISTS: u32 = 13;
pub const KERN_ABORTED: u32 = 14;
pub const KERN_INVALID_NAME: u32 = 15;
pub const KERN_INVALID_TASK: u32 = 16;
pub const KERN_INVALID_RIGHT: u32 = 17;
pub const KERN_INVALID_VALUE: u32 = 18;
pub const KERN_UREFS_OVERFLOW: u32 = 19;
pub const KERN_INVALID_CAPABILITY: u32 = 20;
pub const KERN_RIGHT_EXISTS: u32 = 21;
pub const KERN_INVALID_HOST: u32 = 22;
pub const KERN_MEMORY_PRESENT: u32 = 23;
pub const KERN_MEMORY_DATA_MOVED: u32 = 24;
pub const KERN_MEMORY_RESTART_COPY: u32 = 25;
pub const KERN_INVALID_PROCESSOR_SET: u32 = 26;
pub const KERN_POLICY_LIMIT: u32 = 27;
pub const KERN_INVALID_POLICY: u32 = 28;
pub const KERN_INVALID_OBJECT: u32 = 29;
pub const KERN_ALREADY_WAITING: u32 = 30;
pub const KERN_DEFAULT_SET: u32 = 31;
pub const KERN_EXCEPTION_PROTECTED: u32 = 32;
pub const KERN_INVALID_LEDGER: u32 = 33;
pub const KERN_INVALID_MEMORY_CONTROL: u32 = 34;
pub const KERN_INVALID_SECURITY: u32 = 35;
pub const KERN_NOT_DEPRESSED: u32 = 36;
pub const KERN_TERMINATED: u32 = 37;
pub const KERN_LOCK_SET_DESTROYED: u32 = 38;
pub const KERN_LOCK_UNSTABLE: u32 = 39;
pub const KERN_LOCK_OWNED: u32 = 40;
pub const KERN_LOCK_OWNED_SELF: u32 = 41;
pub const KERN_SEMAPHORE_DESTROYED: u32 = 42;
pub const KERN_RPC_SERVER_TERMINATED: u32 = 43;
pub const KERN_RPC_TERMINATE_ORPHAN: u32 = 44;
pub const KERN_RPC_CONTINUE_ORPHAN: u32 = 45;
pub const KERN_NOT_SUPPORTED: u32 = 46;
pub const KERN_NODE_DOWN: u32 = 47;
pub const KERN_NOT_WAITING: u32 = 48;
pub const KERN_OPERATION_TIMED_OUT: u32 = 49;
pub const KERN_CODESIGN_ERROR: u32 = 50;
pub const KERN_POLICY_STATIC: u32 = 51;
pub const KERN_INSUFFICIENT_BUFFER_SIZE: u32 = 52;
pub const KERN_DENIED: u32 = 53;
pub const KERN_MISSING_KC: u32 = 54;
pub const KERN_INVALID_KC: u32 = 55;
pub const KERN_NOT_FOUND: u32 = 56;
pub const KERN_RETURN_MAX: u32 = 256;
pub const MACH_MSGH_BITS_ZERO: u32 = 0;
pub const MACH_MSGH_BITS_REMOTE_MASK: u32 = 31;
pub const MACH_MSGH_BITS_LOCAL_MASK: u32 = 7936;
pub const MACH_MSGH_BITS_VOUCHER_MASK: u32 = 2031616;
pub const MACH_MSGH_BITS_PORTS_MASK: u32 = 2039583;
pub const MACH_MSGH_BITS_COMPLEX: u32 = 2147483648;
pub const MACH_MSGH_BITS_USER: u32 = 2149523231;
pub const MACH_MSGH_BITS_RAISEIMP: u32 = 536870912;
pub const MACH_MSGH_BITS_DENAP: u32 = 536870912;
pub const MACH_MSGH_BITS_IMPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_DENAPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_CIRCULAR: u32 = 268435456;
pub const MACH_MSGH_BITS_USED: u32 = 2954829599;
pub const MACH_MSG_TYPE_MOVE_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_MOVE_SEND: u32 = 17;
pub const MACH_MSG_TYPE_MOVE_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_COPY_SEND: u32 = 19;
pub const MACH_MSG_TYPE_MAKE_SEND: u32 = 20;
pub const MACH_MSG_TYPE_MAKE_SEND_ONCE: u32 = 21;
pub const MACH_MSG_TYPE_COPY_RECEIVE: u32 = 22;
pub const MACH_MSG_TYPE_DISPOSE_RECEIVE: u32 = 24;
pub const MACH_MSG_TYPE_DISPOSE_SEND: u32 = 25;
pub const MACH_MSG_TYPE_DISPOSE_SEND_ONCE: u32 = 26;
pub const MACH_MSG_PHYSICAL_COPY: u32 = 0;
pub const MACH_MSG_VIRTUAL_COPY: u32 = 1;
pub const MACH_MSG_ALLOCATE: u32 = 2;
pub const MACH_MSG_OVERWRITE: u32 = 3;
pub const MACH_MSG_GUARD_FLAGS_NONE: u32 = 0;
pub const MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE: u32 = 1;
pub const MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND: u32 = 2;
pub const MACH_MSG_GUARD_FLAGS_MASK: u32 = 3;
pub const MACH_MSG_PORT_DESCRIPTOR: u32 = 0;
pub const MACH_MSG_OOL_DESCRIPTOR: u32 = 1;
pub const MACH_MSG_OOL_PORTS_DESCRIPTOR: u32 = 2;
pub const MACH_MSG_OOL_VOLATILE_DESCRIPTOR: u32 = 3;
pub const MACH_MSG_GUARDED_PORT_DESCRIPTOR: u32 = 4;
pub const MACH_MSG_DESCRIPTOR_MAX: u32 = 4;
pub const MACH_MSG_TRAILER_FORMAT_0: u32 = 0;
pub const MACH_MSGH_KIND_NORMAL: u32 = 0;
pub const MACH_MSGH_KIND_NOTIFICATION: u32 = 1;
pub const MACH_MSG_TYPE_PORT_NONE: u32 = 0;
pub const MACH_MSG_TYPE_PORT_NAME: u32 = 15;
pub const MACH_MSG_TYPE_PORT_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_PORT_SEND: u32 = 17;
pub const MACH_MSG_TYPE_PORT_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_LAST: u32 = 22;
pub const MACH_MSG_OPTION_NONE: u32 = 0;
pub const MACH_SEND_MSG: u32 = 1;
pub const MACH_RCV_MSG: u32 = 2;
pub const MACH_RCV_LARGE: u32 = 4;
pub const MACH_RCV_LARGE_IDENTITY: u32 = 8;
pub const MACH_SEND_TIMEOUT: u32 = 16;
pub const MACH_SEND_OVERRIDE: u32 = 32;
pub const MACH_SEND_INTERRUPT: u32 = 64;
pub const MACH_SEND_NOTIFY: u32 = 128;
pub const MACH_SEND_ALWAYS: u32 = 65536;
pub const MACH_SEND_FILTER_NONFATAL: u32 = 65536;
pub const MACH_SEND_TRAILER: u32 = 131072;
pub const MACH_SEND_NOIMPORTANCE: u32 = 262144;
pub const MACH_SEND_NODENAP: u32 = 262144;
pub const MACH_SEND_IMPORTANCE: u32 = 524288;
pub const MACH_SEND_SYNC_OVERRIDE: u32 = 1048576;
pub const MACH_SEND_PROPAGATE_QOS: u32 = 2097152;
pub const MACH_SEND_SYNC_USE_THRPRI: u32 = 2097152;
pub const MACH_SEND_KERNEL: u32 = 4194304;
pub const MACH_SEND_SYNC_BOOTSTRAP_CHECKIN: u32 = 8388608;
pub const MACH_RCV_TIMEOUT: u32 = 256;
pub const MACH_RCV_NOTIFY: u32 = 0;
pub const MACH_RCV_INTERRUPT: u32 = 1024;
pub const MACH_RCV_VOUCHER: u32 = 2048;
pub const MACH_RCV_OVERWRITE: u32 = 0;
pub const MACH_RCV_GUARDED_DESC: u32 = 4096;
pub const MACH_RCV_SYNC_WAIT: u32 = 16384;
pub const MACH_RCV_SYNC_PEEK: u32 = 32768;
pub const MACH_MSG_STRICT_REPLY: u32 = 512;
pub const MACH_RCV_TRAILER_NULL: u32 = 0;
pub const MACH_RCV_TRAILER_SEQNO: u32 = 1;
pub const MACH_RCV_TRAILER_SENDER: u32 = 2;
pub const MACH_RCV_TRAILER_AUDIT: u32 = 3;
pub const MACH_RCV_TRAILER_CTX: u32 = 4;
pub const MACH_RCV_TRAILER_AV: u32 = 7;
pub const MACH_RCV_TRAILER_LABELS: u32 = 8;
pub const MACH_RCV_TRAILER_MASK: u32 = 251658240;
pub const MACH_MSG_SUCCESS: u32 = 0;
pub const MACH_MSG_MASK: u32 = 15872;
pub const MACH_MSG_IPC_SPACE: u32 = 8192;
pub const MACH_MSG_VM_SPACE: u32 = 4096;
pub const MACH_MSG_IPC_KERNEL: u32 = 2048;
pub const MACH_MSG_VM_KERNEL: u32 = 1024;
pub const MACH_SEND_IN_PROGRESS: u32 = 268435457;
pub const MACH_SEND_INVALID_DATA: u32 = 268435458;
pub const MACH_SEND_INVALID_DEST: u32 = 268435459;
pub const MACH_SEND_TIMED_OUT: u32 = 268435460;
pub const MACH_SEND_INVALID_VOUCHER: u32 = 268435461;
pub const MACH_SEND_INTERRUPTED: u32 = 268435463;
pub const MACH_SEND_MSG_TOO_SMALL: u32 = 268435464;
pub const MACH_SEND_INVALID_REPLY: u32 = 268435465;
pub const MACH_SEND_INVALID_RIGHT: u32 = 268435466;
pub const MACH_SEND_INVALID_NOTIFY: u32 = 268435467;
pub const MACH_SEND_INVALID_MEMORY: u32 = 268435468;
pub const MACH_SEND_NO_BUFFER: u32 = 268435469;
pub const MACH_SEND_TOO_LARGE: u32 = 268435470;
pub const MACH_SEND_INVALID_TYPE: u32 = 268435471;
pub const MACH_SEND_INVALID_HEADER: u32 = 268435472;
pub const MACH_SEND_INVALID_TRAILER: u32 = 268435473;
pub const MACH_SEND_INVALID_CONTEXT: u32 = 268435474;
pub const MACH_SEND_INVALID_OPTIONS: u32 = 268435475;
pub const MACH_SEND_INVALID_RT_OOL_SIZE: u32 = 268435477;
pub const MACH_SEND_NO_GRANT_DEST: u32 = 268435478;
pub const MACH_SEND_MSG_FILTERED: u32 = 268435479;
pub const MACH_SEND_AUX_TOO_SMALL: u32 = 268435480;
pub const MACH_SEND_AUX_TOO_LARGE: u32 = 268435481;
pub const MACH_RCV_IN_PROGRESS: u32 = 268451841;
pub const MACH_RCV_INVALID_NAME: u32 = 268451842;
pub const MACH_RCV_TIMED_OUT: u32 = 268451843;
pub const MACH_RCV_TOO_LARGE: u32 = 268451844;
pub const MACH_RCV_INTERRUPTED: u32 = 268451845;
pub const MACH_RCV_PORT_CHANGED: u32 = 268451846;
pub const MACH_RCV_INVALID_NOTIFY: u32 = 268451847;
pub const MACH_RCV_INVALID_DATA: u32 = 268451848;
pub const MACH_RCV_PORT_DIED: u32 = 268451849;
pub const MACH_RCV_IN_SET: u32 = 268451850;
pub const MACH_RCV_HEADER_ERROR: u32 = 268451851;
pub const MACH_RCV_BODY_ERROR: u32 = 268451852;
pub const MACH_RCV_INVALID_TYPE: u32 = 268451853;
pub const MACH_RCV_SCATTER_SMALL: u32 = 268451854;
pub const MACH_RCV_INVALID_TRAILER: u32 = 268451855;
pub const MACH_RCV_IN_PROGRESS_TIMED: u32 = 268451857;
pub const MACH_RCV_INVALID_REPLY: u32 = 268451858;
pub const MACH_RCV_INVALID_ARGUMENTS: u32 = 268451859;
pub const CPU_STATE_MAX: u32 = 4;
pub const CPU_STATE_USER: u32 = 0;
pub const CPU_STATE_SYSTEM: u32 = 1;
pub const CPU_STATE_IDLE: u32 = 2;
pub const CPU_STATE_NICE: u32 = 3;
pub const CPU_ARCH_MASK: u32 = 4278190080;
pub const CPU_ARCH_ABI64: u32 = 16777216;
pub const CPU_ARCH_ABI64_32: u32 = 33554432;
pub const CPU_SUBTYPE_MASK: u32 = 4278190080;
pub const CPU_SUBTYPE_LIB64: u32 = 2147483648;
pub const CPU_SUBTYPE_PTRAUTH_ABI: u32 = 2147483648;
pub const CPU_SUBTYPE_INTEL_FAMILY_MAX: u32 = 15;
pub const CPU_SUBTYPE_INTEL_MODEL_ALL: u32 = 0;
pub const CPU_SUBTYPE_ARM64_PTR_AUTH_MASK: u32 = 251658240;
pub const CPUFAMILY_UNKNOWN: u32 = 0;
pub const CPUFAMILY_POWERPC_G3: u32 = 3471054153;
pub const CPUFAMILY_POWERPC_G4: u32 = 2009171118;
pub const CPUFAMILY_POWERPC_G5: u32 = 3983988906;
pub const CPUFAMILY_INTEL_6_13: u32 = 2855483691;
pub const CPUFAMILY_INTEL_PENRYN: u32 = 2028621756;
pub const CPUFAMILY_INTEL_NEHALEM: u32 = 1801080018;
pub const CPUFAMILY_INTEL_WESTMERE: u32 = 1463508716;
pub const CPUFAMILY_INTEL_SANDYBRIDGE: u32 = 1418770316;
pub const CPUFAMILY_INTEL_IVYBRIDGE: u32 = 526772277;
pub const CPUFAMILY_INTEL_HASWELL: u32 = 280134364;
pub const CPUFAMILY_INTEL_BROADWELL: u32 = 1479463068;
pub const CPUFAMILY_INTEL_SKYLAKE: u32 = 939270559;
pub const CPUFAMILY_INTEL_KABYLAKE: u32 = 260141638;
pub const CPUFAMILY_INTEL_ICELAKE: u32 = 943936839;
pub const CPUFAMILY_INTEL_COMETLAKE: u32 = 486055998;
pub const CPUFAMILY_ARM_9: u32 = 3878847406;
pub const CPUFAMILY_ARM_11: u32 = 2415272152;
pub const CPUFAMILY_ARM_XSCALE: u32 = 1404044789;
pub const CPUFAMILY_ARM_12: u32 = 3172666089;
pub const CPUFAMILY_ARM_13: u32 = 214503012;
pub const CPUFAMILY_ARM_14: u32 = 2517073649;
pub const CPUFAMILY_ARM_15: u32 = 2823887818;
pub const CPUFAMILY_ARM_SWIFT: u32 = 506291073;
pub const CPUFAMILY_ARM_CYCLONE: u32 = 933271106;
pub const CPUFAMILY_ARM_TYPHOON: u32 = 747742334;
pub const CPUFAMILY_ARM_TWISTER: u32 = 2465937352;
pub const CPUFAMILY_ARM_HURRICANE: u32 = 1741614739;
pub const CPUFAMILY_ARM_MONSOON_MISTRAL: u32 = 3894312694;
pub const CPUFAMILY_ARM_VORTEX_TEMPEST: u32 = 131287967;
pub const CPUFAMILY_ARM_LIGHTNING_THUNDER: u32 = 1176831186;
pub const CPUFAMILY_ARM_FIRESTORM_ICESTORM: u32 = 458787763;
pub const CPUFAMILY_ARM_BLIZZARD_AVALANCHE: u32 = 3660830781;
pub const CPUFAMILY_ARM_EVEREST_SAWTOOTH: u32 = 2271604202;
pub const CPUFAMILY_ARM_IBIZA: u32 = 4197663070;
pub const CPUFAMILY_ARM_PALMA: u32 = 1912690738;
pub const CPUFAMILY_ARM_COLL: u32 = 678884789;
pub const CPUFAMILY_ARM_LOBOS: u32 = 1598941843;
pub const CPUSUBFAMILY_UNKNOWN: u32 = 0;
pub const CPUSUBFAMILY_ARM_HP: u32 = 1;
pub const CPUSUBFAMILY_ARM_HG: u32 = 2;
pub const CPUSUBFAMILY_ARM_M: u32 = 3;
pub const CPUSUBFAMILY_ARM_HS: u32 = 4;
pub const CPUSUBFAMILY_ARM_HC_HD: u32 = 5;
pub const CPUSUBFAMILY_ARM_HA: u32 = 6;
pub const CPUFAMILY_INTEL_6_23: u32 = 2028621756;
pub const CPUFAMILY_INTEL_6_26: u32 = 1801080018;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const KAUTH_GUID_SIZE: u32 = 16;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const KAUTH_NTSID_MAX_AUTHORITIES: u32 = 16;
pub const KAUTH_NTSID_HDRSIZE: u32 = 8;
pub const KAUTH_EXTLOOKUP_SUCCESS: u32 = 0;
pub const KAUTH_EXTLOOKUP_BADRQ: u32 = 1;
pub const KAUTH_EXTLOOKUP_FAILURE: u32 = 2;
pub const KAUTH_EXTLOOKUP_FATAL: u32 = 3;
pub const KAUTH_EXTLOOKUP_INPROG: u32 = 100;
pub const KAUTH_EXTLOOKUP_VALID_UID: u32 = 1;
pub const KAUTH_EXTLOOKUP_VALID_UGUID: u32 = 2;
pub const KAUTH_EXTLOOKUP_VALID_USID: u32 = 4;
pub const KAUTH_EXTLOOKUP_VALID_GID: u32 = 8;
pub const KAUTH_EXTLOOKUP_VALID_GGUID: u32 = 16;
pub const KAUTH_EXTLOOKUP_VALID_GSID: u32 = 32;
pub const KAUTH_EXTLOOKUP_WANT_UID: u32 = 64;
pub const KAUTH_EXTLOOKUP_WANT_UGUID: u32 = 128;
pub const KAUTH_EXTLOOKUP_WANT_USID: u32 = 256;
pub const KAUTH_EXTLOOKUP_WANT_GID: u32 = 512;
pub const KAUTH_EXTLOOKUP_WANT_GGUID: u32 = 1024;
pub const KAUTH_EXTLOOKUP_WANT_GSID: u32 = 2048;
pub const KAUTH_EXTLOOKUP_WANT_MEMBERSHIP: u32 = 4096;
pub const KAUTH_EXTLOOKUP_VALID_MEMBERSHIP: u32 = 8192;
pub const KAUTH_EXTLOOKUP_ISMEMBER: u32 = 16384;
pub const KAUTH_EXTLOOKUP_VALID_PWNAM: u32 = 32768;
pub const KAUTH_EXTLOOKUP_WANT_PWNAM: u32 = 65536;
pub const KAUTH_EXTLOOKUP_VALID_GRNAM: u32 = 131072;
pub const KAUTH_EXTLOOKUP_WANT_GRNAM: u32 = 262144;
pub const KAUTH_EXTLOOKUP_VALID_SUPGRPS: u32 = 524288;
pub const KAUTH_EXTLOOKUP_WANT_SUPGRPS: u32 = 1048576;
pub const KAUTH_EXTLOOKUP_REGISTER: u32 = 0;
pub const KAUTH_EXTLOOKUP_RESULT: u32 = 1;
pub const KAUTH_EXTLOOKUP_WORKER: u32 = 2;
pub const KAUTH_EXTLOOKUP_DEREGISTER: u32 = 4;
pub const KAUTH_GET_CACHE_SIZES: u32 = 8;
pub const KAUTH_SET_CACHE_SIZES: u32 = 16;
pub const KAUTH_CLEAR_CACHES: u32 = 32;
pub const IDENTITYSVC_ENTITLEMENT: &[u8; 30] = b"com.apple.private.identitysvc\0";
pub const KAUTH_ACE_KINDMASK: u32 = 15;
pub const KAUTH_ACE_PERMIT: u32 = 1;
pub const KAUTH_ACE_DENY: u32 = 2;
pub const KAUTH_ACE_AUDIT: u32 = 3;
pub const KAUTH_ACE_ALARM: u32 = 4;
pub const KAUTH_ACE_INHERITED: u32 = 16;
pub const KAUTH_ACE_FILE_INHERIT: u32 = 32;
pub const KAUTH_ACE_DIRECTORY_INHERIT: u32 = 64;
pub const KAUTH_ACE_LIMIT_INHERIT: u32 = 128;
pub const KAUTH_ACE_ONLY_INHERIT: u32 = 256;
pub const KAUTH_ACE_SUCCESS: u32 = 512;
pub const KAUTH_ACE_FAILURE: u32 = 1024;
pub const KAUTH_ACE_INHERIT_CONTROL_FLAGS: u32 = 480;
pub const KAUTH_ACE_GENERIC_ALL: u32 = 2097152;
pub const KAUTH_ACE_GENERIC_EXECUTE: u32 = 4194304;
pub const KAUTH_ACE_GENERIC_WRITE: u32 = 8388608;
pub const KAUTH_ACE_GENERIC_READ: u32 = 16777216;
pub const KAUTH_ACL_MAX_ENTRIES: u32 = 128;
pub const KAUTH_ACL_FLAGS_PRIVATE: u32 = 65535;
pub const KAUTH_ACL_DEFER_INHERIT: u32 = 65536;
pub const KAUTH_ACL_NO_INHERIT: u32 = 131072;
pub const KAUTH_FILESEC_MAGIC: u32 = 19710317;
pub const KAUTH_FILESEC_FLAGS_PRIVATE: u32 = 65535;
pub const KAUTH_FILESEC_DEFER_INHERIT: u32 = 65536;
pub const KAUTH_FILESEC_NO_INHERIT: u32 = 131072;
pub const KAUTH_FILESEC_XATTR: &[u8; 26] = b"com.apple.system.Security\0";
pub const KAUTH_ENDIAN_HOST: u32 = 1;
pub const KAUTH_ENDIAN_DISK: u32 = 2;
pub const KAUTH_VNODE_READ_DATA: u32 = 2;
pub const KAUTH_VNODE_LIST_DIRECTORY: u32 = 2;
pub const KAUTH_VNODE_WRITE_DATA: u32 = 4;
pub const KAUTH_VNODE_ADD_FILE: u32 = 4;
pub const KAUTH_VNODE_EXECUTE: u32 = 8;
pub const KAUTH_VNODE_SEARCH: u32 = 8;
pub const KAUTH_VNODE_DELETE: u32 = 16;
pub const KAUTH_VNODE_APPEND_DATA: u32 = 32;
pub const KAUTH_VNODE_ADD_SUBDIRECTORY: u32 = 32;
pub const KAUTH_VNODE_DELETE_CHILD: u32 = 64;
pub const KAUTH_VNODE_READ_ATTRIBUTES: u32 = 128;
pub const KAUTH_VNODE_WRITE_ATTRIBUTES: u32 = 256;
pub const KAUTH_VNODE_READ_EXTATTRIBUTES: u32 = 512;
pub const KAUTH_VNODE_WRITE_EXTATTRIBUTES: u32 = 1024;
pub const KAUTH_VNODE_READ_SECURITY: u32 = 2048;
pub const KAUTH_VNODE_WRITE_SECURITY: u32 = 4096;
pub const KAUTH_VNODE_TAKE_OWNERSHIP: u32 = 8192;
pub const KAUTH_VNODE_CHANGE_OWNER: u32 = 8192;
pub const KAUTH_VNODE_SYNCHRONIZE: u32 = 1048576;
pub const KAUTH_VNODE_LINKTARGET: u32 = 33554432;
pub const KAUTH_VNODE_CHECKIMMUTABLE: u32 = 67108864;
pub const KAUTH_VNODE_ACCESS: u32 = 2147483648;
pub const KAUTH_VNODE_NOIMMUTABLE: u32 = 1073741824;
pub const KAUTH_VNODE_SEARCHBYANYONE: u32 = 536870912;
pub const KAUTH_VNODE_GENERIC_READ_BITS: u32 = 2690;
pub const KAUTH_VNODE_GENERIC_WRITE_BITS: u32 = 5492;
pub const KAUTH_VNODE_GENERIC_EXECUTE_BITS: u32 = 8;
pub const KAUTH_VNODE_GENERIC_ALL_BITS: u32 = 8190;
pub const KAUTH_VNODE_WRITE_RIGHTS: u32 = 100676980;
pub const __DARWIN_ACL_READ_DATA: u32 = 2;
pub const __DARWIN_ACL_LIST_DIRECTORY: u32 = 2;
pub const __DARWIN_ACL_WRITE_DATA: u32 = 4;
pub const __DARWIN_ACL_ADD_FILE: u32 = 4;
pub const __DARWIN_ACL_EXECUTE: u32 = 8;
pub const __DARWIN_ACL_SEARCH: u32 = 8;
pub const __DARWIN_ACL_DELETE: u32 = 16;
pub const __DARWIN_ACL_APPEND_DATA: u32 = 32;
pub const __DARWIN_ACL_ADD_SUBDIRECTORY: u32 = 32;
pub const __DARWIN_ACL_DELETE_CHILD: u32 = 64;
pub const __DARWIN_ACL_READ_ATTRIBUTES: u32 = 128;
pub const __DARWIN_ACL_WRITE_ATTRIBUTES: u32 = 256;
pub const __DARWIN_ACL_READ_EXTATTRIBUTES: u32 = 512;
pub const __DARWIN_ACL_WRITE_EXTATTRIBUTES: u32 = 1024;
pub const __DARWIN_ACL_READ_SECURITY: u32 = 2048;
pub const __DARWIN_ACL_WRITE_SECURITY: u32 = 4096;
pub const __DARWIN_ACL_CHANGE_OWNER: u32 = 8192;
pub const __DARWIN_ACL_SYNCHRONIZE: u32 = 1048576;
pub const __DARWIN_ACL_EXTENDED_ALLOW: u32 = 1;
pub const __DARWIN_ACL_EXTENDED_DENY: u32 = 2;
pub const __DARWIN_ACL_ENTRY_INHERITED: u32 = 16;
pub const __DARWIN_ACL_ENTRY_FILE_INHERIT: u32 = 32;
pub const __DARWIN_ACL_ENTRY_DIRECTORY_INHERIT: u32 = 64;
pub const __DARWIN_ACL_ENTRY_LIMIT_INHERIT: u32 = 128;
pub const __DARWIN_ACL_ENTRY_ONLY_INHERIT: u32 = 256;
pub const __DARWIN_ACL_FLAG_NO_INHERIT: u32 = 131072;
pub const ACL_MAX_ENTRIES: u32 = 128;
pub const BSD: u32 = 199506;
pub const BSD4_3: u32 = 1;
pub const BSD4_4: u32 = 1;
pub const NeXTBSD: u32 = 1995064;
pub const NeXTBSD4_0: u32 = 0;
pub const MAXCOMLEN: u32 = 16;
pub const MAXINTERP: u32 = 64;
pub const MAXLOGNAME: u32 = 255;
pub const MAXUPRC: u32 = 266;
pub const NCARGS: u32 = 1048576;
pub const NGROUPS: u32 = 16;
pub const NOFILE: u32 = 256;
pub const NOGROUP: u32 = 65535;
pub const MAXHOSTNAMELEN: u32 = 256;
pub const MAXDOMNAMELEN: u32 = 256;
pub const NBPG: u32 = 4096;
pub const PGOFSET: u32 = 4095;
pub const PGSHIFT: u32 = 12;
pub const DEV_BSIZE: u32 = 512;
pub const DEV_BSHIFT: u32 = 9;
pub const BLKDEV_IOSIZE: u32 = 2048;
pub const MAXPHYS: u32 = 131072;
pub const CLSIZE: u32 = 1;
pub const CLSIZELOG2: u32 = 0;
pub const MSIZESHIFT: u32 = 8;
pub const MSIZE: u32 = 256;
pub const MCLSHIFT: u32 = 11;
pub const MCLBYTES: u32 = 2048;
pub const MBIGCLSHIFT: u32 = 12;
pub const MBIGCLBYTES: u32 = 4096;
pub const M16KCLSHIFT: u32 = 14;
pub const M16KCLBYTES: u32 = 16384;
pub const MCLOFSET: u32 = 2047;
pub const NMBCLUSTERS: u32 = 512;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 8192;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const _X86_INSTRUCTION_STATE_MAX_INSN_BYTES: u32 = 2380;
pub const _X86_INSTRUCTION_STATE_CACHELINE_SIZE: u32 = 64;
pub const __LASTBRANCH_MAX: u32 = 32;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PSWP: u32 = 0;
pub const PVM: u32 = 4;
pub const PINOD: u32 = 8;
pub const PRIBIO: u32 = 16;
pub const PVFS: u32 = 20;
pub const PZERO: u32 = 22;
pub const PSOCK: u32 = 24;
pub const PWAIT: u32 = 32;
pub const PLOCK: u32 = 36;
pub const PPAUSE: u32 = 40;
pub const PUSER: u32 = 50;
pub const MAXPRI: u32 = 127;
pub const PRIMASK: u32 = 255;
pub const PCATCH: u32 = 256;
pub const PTTYBLOCK: u32 = 512;
pub const PDROP: u32 = 1024;
pub const PSPIN: u32 = 2048;
pub const CMASK: u32 = 18;
pub const CLBYTES: u32 = 4096;
pub const CLOFSET: u32 = 4095;
pub const CLOFF: u32 = 4095;
pub const CLSHIFT: u32 = 12;
pub const CBLOCK: u32 = 64;
pub const CBQSIZE: u32 = 8;
pub const CROUND: u32 = 63;
pub const MAXBSIZE: u32 = 1048576;
pub const MAXPHYSIO: u32 = 131072;
pub const MAXFRAG: u32 = 8;
pub const MAXPHYSIO_WIRED: u32 = 16777216;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXSYMLINKS: u32 = 32;
pub const FSHIFT: u32 = 11;
pub const FSCALE: u32 = 2048;
pub const AUDIT_RECORD_MAGIC: u32 = 2190085915;
pub const MAX_AUDIT_RECORDS: u32 = 20;
pub const MAXAUDITDATA: u32 = 32767;
pub const MAX_AUDIT_RECORD_SIZE: u32 = 32767;
pub const MIN_AUDIT_FILE_SIZE: u32 = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: u32 = 4;
pub const AUDIT_TRIGGER_MIN: u32 = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: u32 = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: u32 = 2;
pub const AUDIT_TRIGGER_READ_FILE: u32 = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: u32 = 4;
pub const AUDIT_TRIGGER_NO_SPACE: u32 = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: u32 = 6;
pub const AUDIT_TRIGGER_INITIALIZE: u32 = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: u32 = 8;
pub const AUDIT_TRIGGER_MAX: u32 = 8;
pub const AUDITDEV_FILENAME: &[u8; 6] = b"audit\0";
pub const AUDIT_TRIGGER_FILE: &[u8; 11] = b"/dev/audit\0";
pub const AU_DEFAUDITSID: u32 = 0;
pub const AU_ASSIGN_ASID: i32 = -1;
pub const AUC_UNSET: u32 = 0;
pub const AUC_AUDITING: u32 = 1;
pub const AUC_NOAUDIT: u32 = 2;
pub const AUC_DISABLED: i32 = -1;
pub const A_OLDGETPOLICY: u32 = 2;
pub const A_OLDSETPOLICY: u32 = 3;
pub const A_GETKMASK: u32 = 4;
pub const A_SETKMASK: u32 = 5;
pub const A_OLDGETQCTRL: u32 = 6;
pub const A_OLDSETQCTRL: u32 = 7;
pub const A_GETCWD: u32 = 8;
pub const A_GETCAR: u32 = 9;
pub const A_GETSTAT: u32 = 12;
pub const A_SETSTAT: u32 = 13;
pub const A_SETUMASK: u32 = 14;
pub const A_SETSMASK: u32 = 15;
pub const A_OLDGETCOND: u32 = 20;
pub const A_OLDSETCOND: u32 = 21;
pub const A_GETCLASS: u32 = 22;
pub const A_SETCLASS: u32 = 23;
pub const A_GETPINFO: u32 = 24;
pub const A_SETPMASK: u32 = 25;
pub const A_SETFSIZE: u32 = 26;
pub const A_GETFSIZE: u32 = 27;
pub const A_GETPINFO_ADDR: u32 = 28;
pub const A_GETKAUDIT: u32 = 29;
pub const A_SETKAUDIT: u32 = 30;
pub const A_SENDTRIGGER: u32 = 31;
pub const A_GETSINFO_ADDR: u32 = 32;
pub const A_GETPOLICY: u32 = 33;
pub const A_SETPOLICY: u32 = 34;
pub const A_GETQCTRL: u32 = 35;
pub const A_SETQCTRL: u32 = 36;
pub const A_GETCOND: u32 = 37;
pub const A_SETCOND: u32 = 38;
pub const A_GETSFLAGS: u32 = 39;
pub const A_SETSFLAGS: u32 = 40;
pub const A_GETCTLMODE: u32 = 41;
pub const A_SETCTLMODE: u32 = 42;
pub const A_GETEXPAFTER: u32 = 43;
pub const A_SETEXPAFTER: u32 = 44;
pub const AUDIT_CNT: u32 = 1;
pub const AUDIT_AHLT: u32 = 2;
pub const AUDIT_ARGV: u32 = 4;
pub const AUDIT_ARGE: u32 = 8;
pub const AUDIT_SEQ: u32 = 16;
pub const AUDIT_WINDATA: u32 = 32;
pub const AUDIT_USER: u32 = 64;
pub const AUDIT_GROUP: u32 = 128;
pub const AUDIT_TRAIL: u32 = 256;
pub const AUDIT_PATH: u32 = 512;
pub const AUDIT_SCNT: u32 = 1024;
pub const AUDIT_PUBLIC: u32 = 2048;
pub const AUDIT_ZONENAME: u32 = 4096;
pub const AUDIT_PERZONE: u32 = 8192;
pub const AQ_HIWATER: u32 = 100;
pub const AQ_MAXHIGH: u32 = 10000;
pub const AQ_LOWATER: u32 = 10;
pub const AQ_BUFSZ: u32 = 32767;
pub const AQ_MAXBUFSZ: u32 = 1048576;
pub const AU_FS_MINFREE: u32 = 20;
pub const AU_IPv4: u32 = 4;
pub const AU_IPv6: u32 = 16;
pub const AU_CLASS_MASK_RESERVED: u32 = 268435456;
pub const CRF_NOMEMBERD: u32 = 1;
pub const CRF_MAC_ENFORCE: u32 = 2;
pub const XUCRED_VERSION: u32 = 0;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const TIME_UTC: u32 = 1;
pub const FSOPT_NOFOLLOW: u32 = 1;
pub const FSOPT_NOINMEMUPDATE: u32 = 2;
pub const FSOPT_REPORT_FULLSIZE: u32 = 4;
pub const FSOPT_PACK_INVAL_ATTRS: u32 = 8;
pub const FSOPT_ATTR_CMN_EXTENDED: u32 = 32;
pub const FSOPT_RETURN_REALDEV: u32 = 512;
pub const FSOPT_NOFOLLOW_ANY: u32 = 2048;
pub const SEARCHFS_MAX_SEARCHPARMS: u32 = 4096;
pub const ATTR_BIT_MAP_COUNT: u32 = 5;
pub const VOL_CAPABILITIES_FORMAT: u32 = 0;
pub const VOL_CAPABILITIES_INTERFACES: u32 = 1;
pub const VOL_CAPABILITIES_RESERVED1: u32 = 2;
pub const VOL_CAPABILITIES_RESERVED2: u32 = 3;
pub const ATTR_MAX_BUFFER: u32 = 8192;
pub const VOL_CAP_FMT_PERSISTENTOBJECTIDS: u32 = 1;
pub const VOL_CAP_FMT_SYMBOLICLINKS: u32 = 2;
pub const VOL_CAP_FMT_HARDLINKS: u32 = 4;
pub const VOL_CAP_FMT_JOURNAL: u32 = 8;
pub const VOL_CAP_FMT_JOURNAL_ACTIVE: u32 = 16;
pub const VOL_CAP_FMT_NO_ROOT_TIMES: u32 = 32;
pub const VOL_CAP_FMT_SPARSE_FILES: u32 = 64;
pub const VOL_CAP_FMT_ZERO_RUNS: u32 = 128;
pub const VOL_CAP_FMT_CASE_SENSITIVE: u32 = 256;
pub const VOL_CAP_FMT_CASE_PRESERVING: u32 = 512;
pub const VOL_CAP_FMT_FAST_STATFS: u32 = 1024;
pub const VOL_CAP_FMT_2TB_FILESIZE: u32 = 2048;
pub const VOL_CAP_FMT_OPENDENYMODES: u32 = 4096;
pub const VOL_CAP_FMT_HIDDEN_FILES: u32 = 8192;
pub const VOL_CAP_FMT_PATH_FROM_ID: u32 = 16384;
pub const VOL_CAP_FMT_NO_VOLUME_SIZES: u32 = 32768;
pub const VOL_CAP_FMT_DECMPFS_COMPRESSION: u32 = 65536;
pub const VOL_CAP_FMT_64BIT_OBJECT_IDS: u32 = 131072;
pub const VOL_CAP_FMT_DIR_HARDLINKS: u32 = 262144;
pub const VOL_CAP_FMT_DOCUMENT_ID: u32 = 524288;
pub const VOL_CAP_FMT_WRITE_GENERATION_COUNT: u32 = 1048576;
pub const VOL_CAP_FMT_NO_IMMUTABLE_FILES: u32 = 2097152;
pub const VOL_CAP_FMT_NO_PERMISSIONS: u32 = 4194304;
pub const VOL_CAP_FMT_SHARED_SPACE: u32 = 8388608;
pub const VOL_CAP_FMT_VOL_GROUPS: u32 = 16777216;
pub const VOL_CAP_FMT_SEALED: u32 = 33554432;
pub const VOL_CAP_INT_SEARCHFS: u32 = 1;
pub const VOL_CAP_INT_ATTRLIST: u32 = 2;
pub const VOL_CAP_INT_NFSEXPORT: u32 = 4;
pub const VOL_CAP_INT_READDIRATTR: u32 = 8;
pub const VOL_CAP_INT_EXCHANGEDATA: u32 = 16;
pub const VOL_CAP_INT_COPYFILE: u32 = 32;
pub const VOL_CAP_INT_ALLOCATE: u32 = 64;
pub const VOL_CAP_INT_VOL_RENAME: u32 = 128;
pub const VOL_CAP_INT_ADVLOCK: u32 = 256;
pub const VOL_CAP_INT_FLOCK: u32 = 512;
pub const VOL_CAP_INT_EXTENDED_SECURITY: u32 = 1024;
pub const VOL_CAP_INT_USERACCESS: u32 = 2048;
pub const VOL_CAP_INT_MANLOCK: u32 = 4096;
pub const VOL_CAP_INT_NAMEDSTREAMS: u32 = 8192;
pub const VOL_CAP_INT_EXTENDED_ATTR: u32 = 16384;
pub const VOL_CAP_INT_CLONE: u32 = 65536;
pub const VOL_CAP_INT_SNAPSHOT: u32 = 131072;
pub const VOL_CAP_INT_RENAME_SWAP: u32 = 262144;
pub const VOL_CAP_INT_RENAME_EXCL: u32 = 524288;
pub const VOL_CAP_INT_RENAME_OPENFAIL: u32 = 1048576;
pub const VOL_CAP_INT_RENAME_SECLUDE: u32 = 2097152;
pub const ATTR_CMN_NAME: u32 = 1;
pub const ATTR_CMN_DEVID: u32 = 2;
pub const ATTR_CMN_FSID: u32 = 4;
pub const ATTR_CMN_OBJTYPE: u32 = 8;
pub const ATTR_CMN_OBJTAG: u32 = 16;
pub const ATTR_CMN_OBJID: u32 = 32;
pub const ATTR_CMN_OBJPERMANENTID: u32 = 64;
pub const ATTR_CMN_PAROBJID: u32 = 128;
pub const ATTR_CMN_SCRIPT: u32 = 256;
pub const ATTR_CMN_CRTIME: u32 = 512;
pub const ATTR_CMN_MODTIME: u32 = 1024;
pub const ATTR_CMN_CHGTIME: u32 = 2048;
pub const ATTR_CMN_ACCTIME: u32 = 4096;
pub const ATTR_CMN_BKUPTIME: u32 = 8192;
pub const ATTR_CMN_FNDRINFO: u32 = 16384;
pub const ATTR_CMN_OWNERID: u32 = 32768;
pub const ATTR_CMN_GRPID: u32 = 65536;
pub const ATTR_CMN_ACCESSMASK: u32 = 131072;
pub const ATTR_CMN_FLAGS: u32 = 262144;
pub const ATTR_CMN_GEN_COUNT: u32 = 524288;
pub const ATTR_CMN_DOCUMENT_ID: u32 = 1048576;
pub const ATTR_CMN_USERACCESS: u32 = 2097152;
pub const ATTR_CMN_EXTENDED_SECURITY: u32 = 4194304;
pub const ATTR_CMN_UUID: u32 = 8388608;
pub const ATTR_CMN_GRPUUID: u32 = 16777216;
pub const ATTR_CMN_FILEID: u32 = 33554432;
pub const ATTR_CMN_PARENTID: u32 = 67108864;
pub const ATTR_CMN_FULLPATH: u32 = 134217728;
pub const ATTR_CMN_ADDEDTIME: u32 = 268435456;
pub const ATTR_CMN_ERROR: u32 = 536870912;
pub const ATTR_CMN_DATA_PROTECT_FLAGS: u32 = 1073741824;
pub const ATTR_CMN_RETURNED_ATTRS: u32 = 2147483648;
pub const ATTR_CMN_VALIDMASK: u32 = 4294967295;
pub const ATTR_CMN_SETMASK: u32 = 1372061440;
pub const ATTR_CMN_VOLSETMASK: u32 = 26368;
pub const ATTR_VOL_FSTYPE: u32 = 1;
pub const ATTR_VOL_SIGNATURE: u32 = 2;
pub const ATTR_VOL_SIZE: u32 = 4;
pub const ATTR_VOL_SPACEFREE: u32 = 8;
pub const ATTR_VOL_SPACEAVAIL: u32 = 16;
pub const ATTR_VOL_MINALLOCATION: u32 = 32;
pub const ATTR_VOL_ALLOCATIONCLUMP: u32 = 64;
pub const ATTR_VOL_IOBLOCKSIZE: u32 = 128;
pub const ATTR_VOL_OBJCOUNT: u32 = 256;
pub const ATTR_VOL_FILECOUNT: u32 = 512;
pub const ATTR_VOL_DIRCOUNT: u32 = 1024;
pub const ATTR_VOL_MAXOBJCOUNT: u32 = 2048;
pub const ATTR_VOL_MOUNTPOINT: u32 = 4096;
pub const ATTR_VOL_NAME: u32 = 8192;
pub const ATTR_VOL_MOUNTFLAGS: u32 = 16384;
pub const ATTR_VOL_MOUNTEDDEVICE: u32 = 32768;
pub const ATTR_VOL_ENCODINGSUSED: u32 = 65536;
pub const ATTR_VOL_CAPABILITIES: u32 = 131072;
pub const ATTR_VOL_UUID: u32 = 262144;
pub const ATTR_VOL_FSTYPENAME: u32 = 1048576;
pub const ATTR_VOL_FSSUBTYPE: u32 = 2097152;
pub const ATTR_VOL_SPACEUSED: u32 = 8388608;
pub const ATTR_VOL_QUOTA_SIZE: u32 = 268435456;
pub const ATTR_VOL_RESERVED_SIZE: u32 = 536870912;
pub const ATTR_VOL_ATTRIBUTES: u32 = 1073741824;
pub const ATTR_VOL_INFO: u32 = 2147483648;
pub const ATTR_VOL_VALIDMASK: u32 = 4038590463;
pub const ATTR_VOL_SETMASK: u32 = 2147491840;
pub const ATTR_DIR_LINKCOUNT: u32 = 1;
pub const ATTR_DIR_ENTRYCOUNT: u32 = 2;
pub const ATTR_DIR_MOUNTSTATUS: u32 = 4;
pub const ATTR_DIR_ALLOCSIZE: u32 = 8;
pub const ATTR_DIR_IOBLOCKSIZE: u32 = 16;
pub const ATTR_DIR_DATALENGTH: u32 = 32;
pub const DIR_MNTSTATUS_MNTPOINT: u32 = 1;
pub const DIR_MNTSTATUS_TRIGGER: u32 = 2;
pub const ATTR_DIR_VALIDMASK: u32 = 63;
pub const ATTR_DIR_SETMASK: u32 = 0;
pub const ATTR_FILE_LINKCOUNT: u32 = 1;
pub const ATTR_FILE_TOTALSIZE: u32 = 2;
pub const ATTR_FILE_ALLOCSIZE: u32 = 4;
pub const ATTR_FILE_IOBLOCKSIZE: u32 = 8;
pub const ATTR_FILE_DEVTYPE: u32 = 32;
pub const ATTR_FILE_FORKCOUNT: u32 = 128;
pub const ATTR_FILE_FORKLIST: u32 = 256;
pub const ATTR_FILE_DATALENGTH: u32 = 512;
pub const ATTR_FILE_DATAALLOCSIZE: u32 = 1024;
pub const ATTR_FILE_RSRCLENGTH: u32 = 4096;
pub const ATTR_FILE_RSRCALLOCSIZE: u32 = 8192;
pub const ATTR_FILE_VALIDMASK: u32 = 14335;
pub const ATTR_FILE_SETMASK: u32 = 32;
pub const ATTR_CMNEXT_RELPATH: u32 = 4;
pub const ATTR_CMNEXT_PRIVATESIZE: u32 = 8;
pub const ATTR_CMNEXT_LINKID: u32 = 16;
pub const ATTR_CMNEXT_NOFIRMLINKPATH: u32 = 32;
pub const ATTR_CMNEXT_REALDEVID: u32 = 64;
pub const ATTR_CMNEXT_REALFSID: u32 = 128;
pub const ATTR_CMNEXT_CLONEID: u32 = 256;
pub const ATTR_CMNEXT_EXT_FLAGS: u32 = 512;
pub const ATTR_CMNEXT_RECURSIVE_GENCOUNT: u32 = 1024;
pub const ATTR_CMNEXT_ATTRIBUTION_TAG: u32 = 2048;
pub const ATTR_CMNEXT_CLONE_REFCNT: u32 = 4096;
pub const ATTR_CMNEXT_VALIDMASK: u32 = 8188;
pub const ATTR_CMNEXT_SETMASK: u32 = 0;
pub const ATTR_FORK_TOTALSIZE: u32 = 1;
pub const ATTR_FORK_ALLOCSIZE: u32 = 2;
pub const ATTR_FORK_RESERVED: u32 = 4294967295;
pub const ATTR_FORK_VALIDMASK: u32 = 3;
pub const ATTR_FORK_SETMASK: u32 = 0;
pub const ATTR_CMN_NAMEDATTRCOUNT: u32 = 524288;
pub const ATTR_CMN_NAMEDATTRLIST: u32 = 1048576;
pub const ATTR_FILE_CLUMPSIZE: u32 = 16;
pub const ATTR_FILE_FILETYPE: u32 = 64;
pub const ATTR_FILE_DATAEXTENTS: u32 = 2048;
pub const ATTR_FILE_RSRCEXTENTS: u32 = 16384;
pub const ATTR_BULK_REQUIRED: u32 = 2147483649;
pub const SRCHFS_START: u32 = 1;
pub const SRCHFS_MATCHPARTIALNAMES: u32 = 2;
pub const SRCHFS_MATCHDIRS: u32 = 4;
pub const SRCHFS_MATCHFILES: u32 = 8;
pub const SRCHFS_SKIPLINKS: u32 = 16;
pub const SRCHFS_SKIPINVISIBLE: u32 = 32;
pub const SRCHFS_SKIPPACKAGES: u32 = 64;
pub const SRCHFS_SKIPINAPPROPRIATE: u32 = 128;
pub const SRCHFS_NEGATEPARAMS: u32 = 2147483648;
pub const SRCHFS_VALIDOPTIONSMASK: u32 = 2147483903;
pub const FST_EOF: i32 = -1;
pub const GRAFTDMG_SECURE_BOOT_CRYPTEX_ARGS_VERSION: u32 = 1;
pub const MAX_GRAFT_ARGS_SIZE: u32 = 512;
pub const SBC_PRESERVE_MOUNT: u32 = 1;
pub const SBC_ALTERNATE_SHARED_REGION: u32 = 2;
pub const SBC_SYSTEM_CONTENT: u32 = 4;
pub const SBC_PANIC_ON_AUTHFAIL: u32 = 8;
pub const SBC_STRICT_AUTH: u32 = 16;
pub const SBC_PRESERVE_GRAFT: u32 = 32;
pub const MFSNAMELEN: u32 = 15;
pub const MFSTYPENAMELEN: u32 = 16;
pub const MNAMELEN: u32 = 1024;
pub const MNT_EXT_ROOT_DATA_VOL: u32 = 1;
pub const MNT_EXT_FSKIT: u32 = 2;
pub const MNT_RDONLY: u32 = 1;
pub const MNT_SYNCHRONOUS: u32 = 2;
pub const MNT_NOEXEC: u32 = 4;
pub const MNT_NOSUID: u32 = 8;
pub const MNT_NODEV: u32 = 16;
pub const MNT_UNION: u32 = 32;
pub const MNT_ASYNC: u32 = 64;
pub const MNT_CPROTECT: u32 = 128;
pub const MNT_EXPORTED: u32 = 256;
pub const MNT_REMOVABLE: u32 = 512;
pub const MNT_QUARANTINE: u32 = 1024;
pub const MNT_LOCAL: u32 = 4096;
pub const MNT_QUOTA: u32 = 8192;
pub const MNT_ROOTFS: u32 = 16384;
pub const MNT_DOVOLFS: u32 = 32768;
pub const MNT_DONTBROWSE: u32 = 1048576;
pub const MNT_IGNORE_OWNERSHIP: u32 = 2097152;
pub const MNT_AUTOMOUNTED: u32 = 4194304;
pub const MNT_JOURNALED: u32 = 8388608;
pub const MNT_NOUSERXATTR: u32 = 16777216;
pub const MNT_DEFWRITE: u32 = 33554432;
pub const MNT_MULTILABEL: u32 = 67108864;
pub const MNT_NOFOLLOW: u32 = 134217728;
pub const MNT_NOATIME: u32 = 268435456;
pub const MNT_SNAPSHOT: u32 = 1073741824;
pub const MNT_STRICTATIME: u32 = 2147483648;
pub const MNT_UNKNOWNPERMISSIONS: u32 = 2097152;
pub const MNT_VISFLAGMASK: u32 = 3757111295;
pub const MNT_UPDATE: u32 = 65536;
pub const MNT_NOBLOCK: u32 = 131072;
pub const MNT_RELOAD: u32 = 262144;
pub const MNT_FORCE: u32 = 524288;
pub const MNT_CMDFLAGS: u32 = 983040;
pub const VFS_GENERIC: u32 = 0;
pub const VFS_NUMMNTOPS: u32 = 1;
pub const VFS_MAXTYPENUM: u32 = 1;
pub const VFS_CONF: u32 = 2;
pub const MNT_WAIT: u32 = 1;
pub const MNT_NOWAIT: u32 = 2;
pub const MNT_DWAIT: u32 = 4;
pub const VFS_CTL_VERS1: u32 = 1;
pub const VFS_CTL_OSTATFS: u32 = 65537;
pub const VFS_CTL_UMOUNT: u32 = 65538;
pub const VFS_CTL_QUERY: u32 = 65539;
pub const VFS_CTL_NEWADDR: u32 = 65540;
pub const VFS_CTL_TIMEO: u32 = 65541;
pub const VFS_CTL_NOLOCKS: u32 = 65542;
pub const VFS_CTL_SADDR: u32 = 65543;
pub const VFS_CTL_DISC: u32 = 65544;
pub const VFS_CTL_SERVERINFO: u32 = 65545;
pub const VFS_CTL_NSTATUS: u32 = 65546;
pub const VFS_CTL_STATFS64: u32 = 65547;
pub const VFS_CTL_STATFS: u32 = 65547;
pub const VQ_NOTRESP: u32 = 1;
pub const VQ_NEEDAUTH: u32 = 2;
pub const VQ_LOWDISK: u32 = 4;
pub const VQ_MOUNT: u32 = 8;
pub const VQ_UNMOUNT: u32 = 16;
pub const VQ_DEAD: u32 = 32;
pub const VQ_ASSIST: u32 = 64;
pub const VQ_NOTRESPLOCK: u32 = 128;
pub const VQ_UPDATE: u32 = 256;
pub const VQ_VERYLOWDISK: u32 = 512;
pub const VQ_SYNCEVENT: u32 = 1024;
pub const VQ_SERVEREVENT: u32 = 2048;
pub const VQ_QUOTA: u32 = 4096;
pub const VQ_NEARLOWDISK: u32 = 8192;
pub const VQ_DESIRED_DISK: u32 = 16384;
pub const VQ_FREE_SPACE_CHANGE: u32 = 32768;
pub const VQ_FLAG10000: u32 = 65536;
pub const NFSV4_MAX_FH_SIZE: u32 = 128;
pub const NFSV3_MAX_FH_SIZE: u32 = 64;
pub const NFSV2_MAX_FH_SIZE: u32 = 32;
pub const CRYPTEX_AUTH_STRUCT_VERSION: u32 = 1;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 10420224;
pub const SF_SETTABLE: u32 = 1073676288;
pub const SF_SYNTHETIC: u32 = 3221225472;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_FIRMLINK: u32 = 8388608;
pub const SF_DATALESS: u32 = 1073741824;
pub const EF_MAY_SHARE_BLOCKS: u32 = 1;
pub const EF_NO_XATTRS: u32 = 2;
pub const EF_IS_SYNC_ROOT: u32 = 4;
pub const EF_IS_PURGEABLE: u32 = 8;
pub const EF_IS_SPARSE: u32 = 16;
pub const EF_IS_SYNTHETIC: u32 = 32;
pub const EF_SHARES_ALL_BLOCKS: u32 = 64;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const XATTR_NOFOLLOW: u32 = 1;
pub const XATTR_CREATE: u32 = 2;
pub const XATTR_REPLACE: u32 = 4;
pub const XATTR_NOSECURITY: u32 = 8;
pub const XATTR_NODEFAULT: u32 = 16;
pub const XATTR_SHOWCOMPRESSION: u32 = 32;
pub const XATTR_MAXNAMELEN: u32 = 127;
pub const XATTR_FINDERINFO_NAME: &[u8; 21] = b"com.apple.FinderInfo\0";
pub const XATTR_RESOURCEFORK_NAME: &[u8; 23] = b"com.apple.ResourceFork\0";
pub const API_TO_BE_DEPRECATED: u32 = 100000;
pub const API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type os_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type os_block_t = *mut ::std::os::raw::c_void;
pub type boolean_t = ::std::os::raw::c_uint;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type mach_port_context_t = mach_vm_address_t;
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_status>(),
        40usize,
        concat!("Size of: ", stringify!(mach_port_status))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_status>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_pset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_pset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_seqno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_mscount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_mscount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_qlimit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_qlimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_msgcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_msgcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_sorights) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_sorights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_srights) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_srights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_pdrequest) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_pdrequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_nsrequest) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_nsrequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_flags)
        )
    );
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_limits> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_limits>(),
        4usize,
        concat!("Size of: ", stringify!(mach_port_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_limits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpl_qlimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_limits),
            "::",
            stringify!(mpl_qlimit)
        )
    );
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_info_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_info_ext>(),
        68usize,
        concat!("Size of: ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_info_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpie_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(mpie_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpie_boost_cnt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(mpie_boost_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(reserved)
        )
    );
}
pub type mach_port_info_ext_t = mach_port_info_ext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_guard_info {
    pub mpgi_guard: u64,
}
#[test]
fn bindgen_test_layout_mach_port_guard_info() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_guard_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_guard_info>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_guard_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpgi_guard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_guard_info),
            "::",
            stringify!(mpgi_guard)
        )
    );
}
pub type mach_port_guard_info_t = mach_port_guard_info;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_qos {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_qos> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_qos>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_qos>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_qos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_qos),
            "::",
            stringify!(len)
        )
    );
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        name: ::std::os::raw::c_uint,
        prealloc: ::std::os::raw::c_uint,
        pad1: boolean_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name: u32 = unsafe { ::std::mem::transmute(name) };
            name as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prealloc: u32 = unsafe { ::std::mem::transmute(prealloc) };
            prealloc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_service_port_info {
    pub mspi_string_name: [::std::os::raw::c_char; 255usize],
    pub mspi_domain_type: u8,
}
#[test]
fn bindgen_test_layout_mach_service_port_info() {
    const UNINIT: ::std::mem::MaybeUninit<mach_service_port_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_service_port_info>(),
        256usize,
        concat!("Size of: ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_service_port_info>(),
        1usize,
        concat!("Alignment of ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mspi_string_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_service_port_info),
            "::",
            stringify!(mspi_string_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mspi_domain_type) as usize - ptr as usize },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_service_port_info),
            "::",
            stringify!(mspi_domain_type)
        )
    );
}
pub type mach_service_port_info_data_t = mach_service_port_info;
pub type mach_service_port_info_t = *mut mach_service_port_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub __bindgen_anon_1: mach_port_options__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_port_options__bindgen_ty_1 {
    pub reserved: [u64; 2usize],
    pub work_interval_port: mach_port_name_t,
    pub service_port_info: mach_service_port_info_t,
    pub service_port_name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_port_options__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_options__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_options__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).work_interval_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(work_interval_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_port_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(service_port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_port_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(service_port_name)
        )
    );
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_options>(),
        24usize,
        concat!("Size of: ", stringify!(mach_port_options))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(mpl)
        )
    );
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
pub const mach_port_guard_exception_codes_kGUARD_EXC_DESTROY: mach_port_guard_exception_codes = 1;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS: mach_port_guard_exception_codes = 2;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_OPTIONS:
    mach_port_guard_exception_codes = 3;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SET_CONTEXT: mach_port_guard_exception_codes =
    4;
pub const mach_port_guard_exception_codes_kGUARD_EXC_THREAD_SET_STATE:
    mach_port_guard_exception_codes = 5;
pub const mach_port_guard_exception_codes_kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE:
    mach_port_guard_exception_codes = 6;
pub const mach_port_guard_exception_codes_kGUARD_EXC_UNGUARDED: mach_port_guard_exception_codes = 8;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INCORRECT_GUARD:
    mach_port_guard_exception_codes = 16;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE: mach_port_guard_exception_codes =
    32;
pub const mach_port_guard_exception_codes_kGUARD_EXC_STRICT_REPLY: mach_port_guard_exception_codes =
    64;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MSG_FILTERED: mach_port_guard_exception_codes =
    128;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_RIGHT:
    mach_port_guard_exception_codes = 256;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_NAME: mach_port_guard_exception_codes =
    512;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_VALUE:
    mach_port_guard_exception_codes = 1024;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_ARGUMENT:
    mach_port_guard_exception_codes = 2048;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RIGHT_EXISTS: mach_port_guard_exception_codes =
    4096;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_NO_SPACE:
    mach_port_guard_exception_codes = 8192;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_FAILURE: mach_port_guard_exception_codes =
    16384;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_RESOURCE:
    mach_port_guard_exception_codes = 32768;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_REPLY:
    mach_port_guard_exception_codes = 65536;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_VOUCHER:
    mach_port_guard_exception_codes = 131072;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_RIGHT:
    mach_port_guard_exception_codes = 262144;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_INVALID_NAME:
    mach_port_guard_exception_codes = 524288;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_GUARDED_DESC:
    mach_port_guard_exception_codes = 1048576;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS_NON_FATAL:
    mach_port_guard_exception_codes = 2097152;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE_NON_FATAL:
    mach_port_guard_exception_codes = 4194304;
pub const mach_port_guard_exception_codes_kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS:
    mach_port_guard_exception_codes = 8388608;
pub type mach_port_guard_exception_codes = ::std::os::raw::c_uint;
pub type kern_return_t = ::std::os::raw::c_int;
pub type mach_msg_timeout_t = natural_t;
pub type mach_msg_bits_t = ::std::os::raw::c_uint;
pub type mach_msg_size_t = natural_t;
pub type mach_msg_id_t = integer_t;
pub type mach_msg_priority_t = ::std::os::raw::c_uint;
pub type mach_msg_type_name_t = ::std::os::raw::c_uint;
pub type mach_msg_copy_options_t = ::std::os::raw::c_uint;
pub type mach_msg_guard_flags_t = ::std::os::raw::c_uint;
pub type mach_msg_descriptor_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_type_descriptor_t {
    pub pad1: natural_t,
    pub pad2: mach_msg_size_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_type_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_type_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_type_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_type_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_type_descriptor_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_type_descriptor_t),
            "::",
            stringify!(pad2)
        )
    );
}
impl mach_msg_type_descriptor_t {
    #[inline]
    pub fn pad3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pad3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad3: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pad3: u32 = unsafe { ::std::mem::transmute(pad3) };
            pad3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_port_descriptor_t {
    pub name: mach_port_t,
    pub pad1: mach_msg_size_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_port_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_port_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_port_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_port_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_port_descriptor_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_port_descriptor_t),
            "::",
            stringify!(pad1)
        )
    );
}
impl mach_msg_port_descriptor_t {
    #[inline]
    pub fn pad2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_pad2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad2: ::std::os::raw::c_uint,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let pad2: u32 = unsafe { ::std::mem::transmute(pad2) };
            pad2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor32_t {
    pub address: u32,
    pub size: mach_msg_size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor32_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_descriptor32_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor32_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor32_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor64_t {
    pub address: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor64_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_descriptor64_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor64_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor64_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor32_t {
    pub address: u32,
    pub count: mach_msg_size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor32_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_ports_descriptor32_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor32_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor32_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor32_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor64_t {
    pub address: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor64_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_ports_descriptor64_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor64_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor64_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor64_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_ports_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor32_t {
    pub context: u32,
    pub name: mach_port_name_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor32_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_guarded_port_descriptor32_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor32_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(mach_msg_guarded_port_descriptor32_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor32_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor32_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor32_t),
            "::",
            stringify!(name)
        )
    );
}
impl mach_msg_guarded_port_descriptor32_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor64_t {
    pub context: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor64_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_guarded_port_descriptor64_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor64_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(mach_msg_guarded_port_descriptor64_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor64_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor64_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor64_t),
            "::",
            stringify!(name)
        )
    );
}
impl mach_msg_guarded_port_descriptor64_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor_t {
    pub context: mach_port_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_guarded_port_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_guarded_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor_t),
            "::",
            stringify!(name)
        )
    );
}
impl mach_msg_guarded_port_descriptor_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_descriptor_t {
    pub port: mach_msg_port_descriptor_t,
    pub out_of_line: mach_msg_ool_descriptor_t,
    pub ool_ports: mach_msg_ool_ports_descriptor_t,
    pub type_: mach_msg_type_descriptor_t,
    pub guarded_port: mach_msg_guarded_port_descriptor_t,
}
#[test]
fn bindgen_test_layout_mach_msg_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_of_line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(out_of_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ool_ports) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(ool_ports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guarded_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(guarded_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_body_t {
    pub msgh_descriptor_count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_body_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_body_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_body_t>(),
        4usize,
        concat!("Size of: ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_body_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_descriptor_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_body_t),
            "::",
            stringify!(msgh_descriptor_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_header_t {
    pub msgh_bits: mach_msg_bits_t,
    pub msgh_size: mach_msg_size_t,
    pub msgh_remote_port: mach_port_t,
    pub msgh_local_port: mach_port_t,
    pub msgh_voucher_port: mach_port_name_t,
    pub msgh_id: mach_msg_id_t,
}
#[test]
fn bindgen_test_layout_mach_msg_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_header_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_header_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_header_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_remote_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_local_port) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_voucher_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_voucher_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_base_t {
    pub header: mach_msg_header_t,
    pub body: mach_msg_body_t,
}
#[test]
fn bindgen_test_layout_mach_msg_base_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_base_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_base_t>(),
        28usize,
        concat!("Size of: ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_base_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_base_t),
            "::",
            stringify!(body)
        )
    );
}
pub type mach_msg_trailer_type_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_size_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_info_t = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_trailer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_trailer_t>(),
        8usize,
        concat!("Size of: ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_seqno_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
}
#[test]
fn bindgen_test_layout_mach_msg_seqno_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_seqno_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_seqno_trailer_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_seqno_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct security_token_t {
    pub val: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_security_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<security_token_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<security_token_t>(),
        8usize,
        concat!("Size of: ", stringify!(security_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<security_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(security_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(security_token_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_security_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_security_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_security_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_security_trailer_t>(),
        20usize,
        concat!("Size of: ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_security_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_token_t {
    pub val: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_audit_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<audit_token_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audit_token_t>(),
        32usize,
        concat!("Size of: ", stringify!(audit_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_token_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_audit_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_audit_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_audit_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_audit_trailer_t>(),
        52usize,
        concat!("Size of: ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_audit_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_context_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
}
#[test]
fn bindgen_test_layout_mach_msg_context_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_context_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_context_trailer_t>(),
        60usize,
        concat!("Size of: ", stringify!(mach_msg_context_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_context_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_context_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_context) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_labels_t {
    pub sender: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_msg_labels_t() {
    const UNINIT: ::std::mem::MaybeUninit<msg_labels_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msg_labels_t>(),
        4usize,
        concat!("Size of: ", stringify!(msg_labels_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_labels_t>(),
        4usize,
        concat!("Alignment of ", stringify!(msg_labels_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_labels_t),
            "::",
            stringify!(sender)
        )
    );
}
pub type mach_msg_filter_id = ::std::os::raw::c_int;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_mac_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
    pub msgh_ad: mach_msg_filter_id,
    pub msgh_labels: msg_labels_t,
}
#[test]
fn bindgen_test_layout_mach_msg_mac_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_mac_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_mac_trailer_t>(),
        68usize,
        concat!("Size of: ", stringify!(mach_msg_mac_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_mac_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_mac_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_context) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_ad) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_ad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_labels) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_labels)
        )
    );
}
pub type mach_msg_max_trailer_t = mach_msg_mac_trailer_t;
pub type mach_msg_format_0_trailer_t = mach_msg_security_trailer_t;
extern "C" {
    pub static KERNEL_SECURITY_TOKEN: security_token_t;
}
extern "C" {
    pub static KERNEL_AUDIT_TOKEN: audit_token_t;
}
pub type mach_msg_options_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_empty_send_t {
    pub header: mach_msg_header_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_send_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_empty_send_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_send_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_send_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_send_t),
            "::",
            stringify!(header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_empty_rcv_t {
    pub header: mach_msg_header_t,
    pub trailer: mach_msg_trailer_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_rcv_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_empty_rcv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_rcv_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_rcv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_rcv_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_rcv_t),
            "::",
            stringify!(trailer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_empty_t {
    pub send: mach_msg_empty_send_t,
    pub rcv: mach_msg_empty_rcv_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_empty_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_t),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_t),
            "::",
            stringify!(rcv)
        )
    );
}
pub type mach_msg_type_size_t = natural_t;
pub type mach_msg_type_number_t = natural_t;
pub type mach_msg_option_t = integer_t;
pub type mach_msg_return_t = kern_return_t;
extern "C" {
    pub fn mach_msg_overwrite(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
        rcv_msg: *mut mach_msg_header_t,
        rcv_limit: mach_msg_size_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_msg(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_voucher_deallocate(voucher: mach_port_name_t) -> kern_return_t;
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
extern "C" {
    pub static UUID_NULL: uuid_t;
}
extern "C" {
    pub fn uuid_clear(uu: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_compare(
        uu1: *mut ::std::os::raw::c_uchar,
        uu2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_copy(dst: *mut ::std::os::raw::c_uchar, src: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate_random(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate_time(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_is_null(uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_parse(
        in_: *mut ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_unparse(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn uuid_unparse_lower(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn uuid_unparse_upper(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_id_t {
    pub reserved: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_es_event_id_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_id_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_id_t>(),
        32usize,
        concat!("Size of: ", stringify!(es_event_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(es_event_id_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_id_t),
            "::",
            stringify!(reserved)
        )
    );
}
pub const es_action_type_t_ES_ACTION_TYPE_AUTH: es_action_type_t = 0;
pub const es_action_type_t_ES_ACTION_TYPE_NOTIFY: es_action_type_t = 1;
pub type es_action_type_t = ::std::os::raw::c_uint;
pub const es_set_or_clear_t_ES_SET: es_set_or_clear_t = 0;
pub const es_set_or_clear_t_ES_CLEAR: es_set_or_clear_t = 1;
pub type es_set_or_clear_t = ::std::os::raw::c_uint;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_LISTPIDS: es_proc_check_type_t = 1;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_PIDINFO: es_proc_check_type_t = 2;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_PIDFDINFO: es_proc_check_type_t = 3;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_KERNMSGBUF: es_proc_check_type_t = 4;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_SETCONTROL: es_proc_check_type_t = 5;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_PIDFILEPORTINFO: es_proc_check_type_t = 6;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_TERMINATE: es_proc_check_type_t = 7;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_DIRTYCONTROL: es_proc_check_type_t = 8;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_PIDRUSAGE: es_proc_check_type_t = 9;
pub const es_proc_check_type_t_ES_PROC_CHECK_TYPE_UDATA_INFO: es_proc_check_type_t = 14;
#[doc = " @brief This enum describes the type of the es_event_proc_check_t event that are currently used\n\n @note ES_PROC_CHECK_TYPE_KERNMSGBUF, ES_PROC_CHECK_TYPE_TERMINATE and\n ES_PROC_CHECK_TYPE_UDATA_INFO are deprecated and no proc_check messages will be generated\n for the corresponding proc_info call numbers.\n The terminate callnum is covered by the signal event."]
pub type es_proc_check_type_t = ::std::os::raw::c_uint;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_SYSTEM: es_xpc_domain_type_t = 1;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_USER: es_xpc_domain_type_t = 2;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_USER_LOGIN: es_xpc_domain_type_t = 3;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_SESSION: es_xpc_domain_type_t = 4;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_PID: es_xpc_domain_type_t = 5;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_MANAGER: es_xpc_domain_type_t = 6;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_PORT: es_xpc_domain_type_t = 7;
pub const es_xpc_domain_type_t_ES_XPC_DOMAIN_TYPE_GUI: es_xpc_domain_type_t = 8;
#[doc = " @brief This enum describes the types of XPC service domains."]
pub type es_xpc_domain_type_t = ::std::os::raw::c_uint;
pub const es_authentication_type_t_ES_AUTHENTICATION_TYPE_OD: es_authentication_type_t = 0;
pub const es_authentication_type_t_ES_AUTHENTICATION_TYPE_TOUCHID: es_authentication_type_t = 1;
pub const es_authentication_type_t_ES_AUTHENTICATION_TYPE_TOKEN: es_authentication_type_t = 2;
pub const es_authentication_type_t_ES_AUTHENTICATION_TYPE_AUTO_UNLOCK: es_authentication_type_t = 3;
pub const es_authentication_type_t_ES_AUTHENTICATION_TYPE_LAST: es_authentication_type_t = 4;
#[doc = " @brief This enum describes the types of authentications that\n ES_EVENT_TYPE_NOTIFY_AUTHENTICATION can describe."]
pub type es_authentication_type_t = ::std::os::raw::c_uint;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_EXEC: es_event_type_t = 0;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_OPEN: es_event_type_t = 1;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_KEXTLOAD: es_event_type_t = 2;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_MMAP: es_event_type_t = 3;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_MPROTECT: es_event_type_t = 4;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_MOUNT: es_event_type_t = 5;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_RENAME: es_event_type_t = 6;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SIGNAL: es_event_type_t = 7;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_UNLINK: es_event_type_t = 8;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_EXEC: es_event_type_t = 9;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OPEN: es_event_type_t = 10;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_FORK: es_event_type_t = 11;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_CLOSE: es_event_type_t = 12;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_CREATE: es_event_type_t = 13;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_EXCHANGEDATA: es_event_type_t = 14;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_EXIT: es_event_type_t = 15;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_GET_TASK: es_event_type_t = 16;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_KEXTLOAD: es_event_type_t = 17;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_KEXTUNLOAD: es_event_type_t = 18;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LINK: es_event_type_t = 19;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_MMAP: es_event_type_t = 20;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_MPROTECT: es_event_type_t = 21;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_MOUNT: es_event_type_t = 22;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_UNMOUNT: es_event_type_t = 23;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_IOKIT_OPEN: es_event_type_t = 24;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_RENAME: es_event_type_t = 25;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETATTRLIST: es_event_type_t = 26;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETEXTATTR: es_event_type_t = 27;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETFLAGS: es_event_type_t = 28;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETMODE: es_event_type_t = 29;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETOWNER: es_event_type_t = 30;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SIGNAL: es_event_type_t = 31;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_UNLINK: es_event_type_t = 32;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_WRITE: es_event_type_t = 33;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_FILE_PROVIDER_MATERIALIZE: es_event_type_t = 34;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_FILE_PROVIDER_MATERIALIZE: es_event_type_t = 35;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_FILE_PROVIDER_UPDATE: es_event_type_t = 36;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_FILE_PROVIDER_UPDATE: es_event_type_t = 37;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_READLINK: es_event_type_t = 38;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_READLINK: es_event_type_t = 39;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_TRUNCATE: es_event_type_t = 40;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_TRUNCATE: es_event_type_t = 41;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_LINK: es_event_type_t = 42;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LOOKUP: es_event_type_t = 43;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_CREATE: es_event_type_t = 44;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETATTRLIST: es_event_type_t = 45;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETEXTATTR: es_event_type_t = 46;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETFLAGS: es_event_type_t = 47;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETMODE: es_event_type_t = 48;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETOWNER: es_event_type_t = 49;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_CHDIR: es_event_type_t = 50;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_CHDIR: es_event_type_t = 51;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_GETATTRLIST: es_event_type_t = 52;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_GETATTRLIST: es_event_type_t = 53;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_STAT: es_event_type_t = 54;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_ACCESS: es_event_type_t = 55;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_CHROOT: es_event_type_t = 56;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_CHROOT: es_event_type_t = 57;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_UTIMES: es_event_type_t = 58;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_UTIMES: es_event_type_t = 59;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_CLONE: es_event_type_t = 60;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_CLONE: es_event_type_t = 61;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_FCNTL: es_event_type_t = 62;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_GETEXTATTR: es_event_type_t = 63;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_GETEXTATTR: es_event_type_t = 64;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_LISTEXTATTR: es_event_type_t = 65;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LISTEXTATTR: es_event_type_t = 66;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_READDIR: es_event_type_t = 67;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_READDIR: es_event_type_t = 68;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_DELETEEXTATTR: es_event_type_t = 69;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR: es_event_type_t = 70;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_FSGETPATH: es_event_type_t = 71;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_FSGETPATH: es_event_type_t = 72;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_DUP: es_event_type_t = 73;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETTIME: es_event_type_t = 74;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETTIME: es_event_type_t = 75;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_UIPC_BIND: es_event_type_t = 76;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_UIPC_BIND: es_event_type_t = 77;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_UIPC_CONNECT: es_event_type_t = 78;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_UIPC_CONNECT: es_event_type_t = 79;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_EXCHANGEDATA: es_event_type_t = 80;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SETACL: es_event_type_t = 81;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETACL: es_event_type_t = 82;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_PTY_GRANT: es_event_type_t = 83;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_PTY_CLOSE: es_event_type_t = 84;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_PROC_CHECK: es_event_type_t = 85;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_PROC_CHECK: es_event_type_t = 86;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_GET_TASK: es_event_type_t = 87;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_SEARCHFS: es_event_type_t = 88;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SEARCHFS: es_event_type_t = 89;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_FCNTL: es_event_type_t = 90;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_IOKIT_OPEN: es_event_type_t = 91;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_PROC_SUSPEND_RESUME: es_event_type_t = 92;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_PROC_SUSPEND_RESUME: es_event_type_t = 93;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_CS_INVALIDATED: es_event_type_t = 94;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_GET_TASK_NAME: es_event_type_t = 95;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_TRACE: es_event_type_t = 96;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_REMOTE_THREAD_CREATE: es_event_type_t = 97;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_REMOUNT: es_event_type_t = 98;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_REMOUNT: es_event_type_t = 99;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_GET_TASK_READ: es_event_type_t = 100;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_GET_TASK_READ: es_event_type_t = 101;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_GET_TASK_INSPECT: es_event_type_t = 102;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETUID: es_event_type_t = 103;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETGID: es_event_type_t = 104;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETEUID: es_event_type_t = 105;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETEGID: es_event_type_t = 106;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETREUID: es_event_type_t = 107;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SETREGID: es_event_type_t = 108;
pub const es_event_type_t_ES_EVENT_TYPE_AUTH_COPYFILE: es_event_type_t = 109;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_COPYFILE: es_event_type_t = 110;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_AUTHENTICATION: es_event_type_t = 111;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_XP_MALWARE_DETECTED: es_event_type_t = 112;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_XP_MALWARE_REMEDIATED: es_event_type_t = 113;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LW_SESSION_LOGIN: es_event_type_t = 114;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LW_SESSION_LOGOUT: es_event_type_t = 115;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LW_SESSION_LOCK: es_event_type_t = 116;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LW_SESSION_UNLOCK: es_event_type_t = 117;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SCREENSHARING_ATTACH: es_event_type_t = 118;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SCREENSHARING_DETACH: es_event_type_t = 119;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OPENSSH_LOGIN: es_event_type_t = 120;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OPENSSH_LOGOUT: es_event_type_t = 121;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LOGIN_LOGIN: es_event_type_t = 122;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_LOGIN_LOGOUT: es_event_type_t = 123;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD: es_event_type_t = 124;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_REMOVE: es_event_type_t = 125;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_PROFILE_ADD: es_event_type_t = 126;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_PROFILE_REMOVE: es_event_type_t = 127;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SU: es_event_type_t = 128;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_AUTHORIZATION_PETITION: es_event_type_t = 129;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_AUTHORIZATION_JUDGEMENT: es_event_type_t = 130;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_SUDO: es_event_type_t = 131;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_GROUP_ADD: es_event_type_t = 132;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_GROUP_REMOVE: es_event_type_t = 133;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_GROUP_SET: es_event_type_t = 134;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_MODIFY_PASSWORD: es_event_type_t = 135;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_DISABLE_USER: es_event_type_t = 136;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_ENABLE_USER: es_event_type_t = 137;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_ATTRIBUTE_VALUE_ADD: es_event_type_t = 138;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_ATTRIBUTE_VALUE_REMOVE: es_event_type_t = 139;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_ATTRIBUTE_SET: es_event_type_t = 140;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_CREATE_USER: es_event_type_t = 141;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_CREATE_GROUP: es_event_type_t = 142;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_DELETE_USER: es_event_type_t = 143;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_OD_DELETE_GROUP: es_event_type_t = 144;
pub const es_event_type_t_ES_EVENT_TYPE_NOTIFY_XPC_CONNECT: es_event_type_t = 145;
pub const es_event_type_t_ES_EVENT_TYPE_LAST: es_event_type_t = 146;
#[doc = " The valid event types recognized by EndpointSecurity\n\n @discussion When a program subscribes to and receives an AUTH-related event, it must respond\n with an appropriate result indicating whether or not the operation should be allowed to continue.\n The valid API options are:\n - es_respond_auth_result\n - es_respond_flags_result\n\n Currently, only ES_EVENT_TYPE_AUTH_OPEN must use es_respond_flags_result. All other AUTH events\n must use es_respond_auth_result."]
pub type es_event_type_t = ::std::os::raw::c_uint;
#[doc = " The event is authorized and should be allowed to continue"]
pub const es_auth_result_t_ES_AUTH_RESULT_ALLOW: es_auth_result_t = 0;
#[doc = " The event is not authorized and should be blocked"]
pub const es_auth_result_t_ES_AUTH_RESULT_DENY: es_auth_result_t = 1;
#[doc = " @brief Valid authorization values to be used when responding to a es_message_t auth event"]
pub type es_auth_result_t = ::std::os::raw::c_uint;
#[doc = " The result is an auth result"]
pub const es_result_type_t_ES_RESULT_TYPE_AUTH: es_result_type_t = 0;
#[doc = " The result is a flags result"]
pub const es_result_type_t_ES_RESULT_TYPE_FLAGS: es_result_type_t = 1;
#[doc = " @brief Valid values for the result_type of es_result_t to indicate the appropriate union member to use"]
pub type es_result_type_t = ::std::os::raw::c_uint;
pub const es_return_t_ES_RETURN_SUCCESS: es_return_t = 0;
pub const es_return_t_ES_RETURN_ERROR: es_return_t = 1;
#[doc = "@brief Return value for functions that can only fail in one way"]
pub type es_return_t = ::std::os::raw::c_uint;
pub const es_respond_result_t_ES_RESPOND_RESULT_SUCCESS: es_respond_result_t = 0;
#[doc = "One or more invalid arguments were provided"]
pub const es_respond_result_t_ES_RESPOND_RESULT_ERR_INVALID_ARGUMENT: es_respond_result_t = 1;
#[doc = "Communication with the ES subsystem failed"]
pub const es_respond_result_t_ES_RESPOND_RESULT_ERR_INTERNAL: es_respond_result_t = 2;
#[doc = "The message being responded to could not be found"]
pub const es_respond_result_t_ES_RESPOND_RESULT_NOT_FOUND: es_respond_result_t = 3;
#[doc = "The provided message has been responded to more than once"]
pub const es_respond_result_t_ES_RESPOND_RESULT_ERR_DUPLICATE_RESPONSE: es_respond_result_t = 4;
#[doc = "Either an inappropriate response API was used for the event type (ensure using proper\nes_respond_auth_result or es_respond_flags_result function) or the event is notification only."]
pub const es_respond_result_t_ES_RESPOND_RESULT_ERR_EVENT_TYPE: es_respond_result_t = 5;
#[doc = "@brief Error conditions for responding to a message"]
pub type es_respond_result_t = ::std::os::raw::c_uint;
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_SUCCESS: es_new_client_result_t = 0;
#[doc = " One or more invalid arguments were provided."]
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_ERR_INVALID_ARGUMENT: es_new_client_result_t =
    1;
#[doc = " Communication with the ES subsystem failed, or other error condition."]
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_ERR_INTERNAL: es_new_client_result_t = 2;
#[doc = " The caller is not properly entitled to connect."]
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_ERR_NOT_ENTITLED: es_new_client_result_t = 3;
#[doc = " The caller lacks Transparency, Consent, and Control (TCC) approval from the user."]
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_ERR_NOT_PERMITTED: es_new_client_result_t = 4;
#[doc = " The caller is not running as root."]
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_ERR_NOT_PRIVILEGED: es_new_client_result_t =
    5;
#[doc = " The caller has reached the maximum number of allowed simultaneously connected clients."]
pub const es_new_client_result_t_ES_NEW_CLIENT_RESULT_ERR_TOO_MANY_CLIENTS: es_new_client_result_t =
    6;
#[doc = "@brief Error conditions for creating a new client"]
pub type es_new_client_result_t = ::std::os::raw::c_uint;
pub const es_clear_cache_result_t_ES_CLEAR_CACHE_RESULT_SUCCESS: es_clear_cache_result_t = 0;
#[doc = "Communication with the ES subsystem failed"]
pub const es_clear_cache_result_t_ES_CLEAR_CACHE_RESULT_ERR_INTERNAL: es_clear_cache_result_t = 1;
#[doc = "Rate of calls is too high. Slow down."]
pub const es_clear_cache_result_t_ES_CLEAR_CACHE_RESULT_ERR_THROTTLE: es_clear_cache_result_t = 2;
#[doc = "@brief Error conditions for clearing the authorisation caches"]
pub type es_clear_cache_result_t = ::std::os::raw::c_uint;
#[doc = " @brief Structure buffer with size"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_token_t {
    pub size: usize,
    pub data: *const u8,
}
#[test]
fn bindgen_test_layout_es_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_token_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_token_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_token_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_token_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_token_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief Structure for handling strings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_string_token_t {
    pub length: usize,
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_es_string_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_string_token_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_string_token_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_string_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_string_token_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_string_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_string_token_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_string_token_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Value to describe a path prefix"]
pub const es_mute_path_type_t_ES_MUTE_PATH_TYPE_PREFIX: es_mute_path_type_t = 0;
#[doc = " Value to describe a path literal"]
pub const es_mute_path_type_t_ES_MUTE_PATH_TYPE_LITERAL: es_mute_path_type_t = 1;
#[doc = " Value to describe a target path prefix"]
pub const es_mute_path_type_t_ES_MUTE_PATH_TYPE_TARGET_PREFIX: es_mute_path_type_t = 2;
#[doc = " Value to describe a target path literal"]
pub const es_mute_path_type_t_ES_MUTE_PATH_TYPE_TARGET_LITERAL: es_mute_path_type_t = 3;
pub type es_mute_path_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_muted_path_t {
    pub type_: es_mute_path_type_t,
    pub event_count: usize,
    pub events: *const es_event_type_t,
    pub path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_muted_path_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_muted_path_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_muted_path_t>(),
        40usize,
        concat!("Size of: ", stringify!(es_muted_path_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_muted_path_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_muted_path_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_path_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_path_t),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_path_t),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_path_t),
            "::",
            stringify!(path)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_muted_paths_t {
    pub count: usize,
    pub paths: *const es_muted_path_t,
}
#[test]
fn bindgen_test_layout_es_muted_paths_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_muted_paths_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_muted_paths_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_muted_paths_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_muted_paths_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_muted_paths_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_paths_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paths) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_paths_t),
            "::",
            stringify!(paths)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_muted_process_t {
    pub audit_token: audit_token_t,
    pub event_count: usize,
    pub events: *const es_event_type_t,
}
#[test]
fn bindgen_test_layout_es_muted_process_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_muted_process_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_muted_process_t>(),
        48usize,
        concat!("Size of: ", stringify!(es_muted_process_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_muted_process_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_muted_process_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audit_token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_process_t),
            "::",
            stringify!(audit_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_process_t),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_process_t),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_muted_processes_t {
    pub count: usize,
    pub processes: *const es_muted_process_t,
}
#[test]
fn bindgen_test_layout_es_muted_processes_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_muted_processes_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_muted_processes_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_muted_processes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_muted_processes_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_muted_processes_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_processes_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_muted_processes_t),
            "::",
            stringify!(processes)
        )
    );
}
#[doc = " No source address available."]
pub const es_address_type_t_ES_ADDRESS_TYPE_NONE: es_address_type_t = 0;
#[doc = " Source address is IPv4."]
pub const es_address_type_t_ES_ADDRESS_TYPE_IPV4: es_address_type_t = 1;
#[doc = " Source address is IPv6."]
pub const es_address_type_t_ES_ADDRESS_TYPE_IPV6: es_address_type_t = 2;
#[doc = " Source address is named UNIX socket."]
pub const es_address_type_t_ES_ADDRESS_TYPE_NAMED_SOCKET: es_address_type_t = 3;
pub type es_address_type_t = ::std::os::raw::c_uint;
pub const es_mute_inversion_type_t_ES_MUTE_INVERSION_TYPE_PROCESS: es_mute_inversion_type_t = 0;
pub const es_mute_inversion_type_t_ES_MUTE_INVERSION_TYPE_PATH: es_mute_inversion_type_t = 1;
pub const es_mute_inversion_type_t_ES_MUTE_INVERSION_TYPE_TARGET_PATH: es_mute_inversion_type_t = 2;
pub const es_mute_inversion_type_t_ES_MUTE_INVERSION_TYPE_LAST: es_mute_inversion_type_t = 3;
pub type es_mute_inversion_type_t = ::std::os::raw::c_uint;
#[doc = " The type of muted queried was inverted"]
pub const es_mute_inverted_return_t_ES_MUTE_INVERTED: es_mute_inverted_return_t = 0;
#[doc = " The type of muted queried was not inverted"]
pub const es_mute_inverted_return_t_ES_MUTE_NOT_INVERTED: es_mute_inverted_return_t = 1;
#[doc = " There was an error querying mute inversion state"]
pub const es_mute_inverted_return_t_ES_MUTE_INVERTED_ERROR: es_mute_inverted_return_t = 2;
pub type es_mute_inverted_return_t = ::std::os::raw::c_uint;
#[doc = " Right is judged on user properties"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_USER:
    es_authorization_rule_class_t = 0;
#[doc = " Right is judged by a tree of sub-rules"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_RULE:
    es_authorization_rule_class_t = 1;
#[doc = " Right is judged by one or more plugins"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_MECHANISM:
    es_authorization_rule_class_t = 2;
#[doc = " Right is always granted"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_ALLOW:
    es_authorization_rule_class_t = 3;
#[doc = " Right is always denied"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_DENY:
    es_authorization_rule_class_t = 4;
#[doc = " Right is unknown"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_UNKNOWN:
    es_authorization_rule_class_t = 5;
#[doc = " Right is invalid"]
pub const es_authorization_rule_class_t_ES_AUTHORIZATION_RULE_CLASS_INVALID:
    es_authorization_rule_class_t = 6;
pub type es_authorization_rule_class_t = ::std::os::raw::c_uint;
#[doc = " Group member is a user, designated by name"]
pub const es_od_member_type_t_ES_OD_MEMBER_TYPE_USER_NAME: es_od_member_type_t = 0;
#[doc = " Group member is a user, designated by UUID"]
pub const es_od_member_type_t_ES_OD_MEMBER_TYPE_USER_UUID: es_od_member_type_t = 1;
#[doc = " Group member is another group, designated by UUID"]
pub const es_od_member_type_t_ES_OD_MEMBER_TYPE_GROUP_UUID: es_od_member_type_t = 2;
pub type es_od_member_type_t = ::std::os::raw::c_uint;
pub const es_od_account_type_t_ES_OD_ACCOUNT_TYPE_USER: es_od_account_type_t = 0;
pub const es_od_account_type_t_ES_OD_ACCOUNT_TYPE_COMPUTER: es_od_account_type_t = 1;
pub type es_od_account_type_t = ::std::os::raw::c_uint;
pub const es_od_record_type_t_ES_OD_RECORD_TYPE_USER: es_od_record_type_t = 0;
pub const es_od_record_type_t_ES_OD_RECORD_TYPE_GROUP: es_od_record_type_t = 1;
pub type es_od_record_type_t = ::std::os::raw::c_uint;
pub type cpu_type_t = integer_t;
pub type cpu_subtype_t = integer_t;
pub type cpu_threadtype_t = integer_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union guid_t {
    pub g_guid: [::std::os::raw::c_uchar; 16usize],
    pub g_guid_asint: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_guid_t() {
    const UNINIT: ::std::mem::MaybeUninit<guid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<guid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(guid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(guid_t),
            "::",
            stringify!(g_guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_guid_asint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(guid_t),
            "::",
            stringify!(g_guid_asint)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ntsid_t {
    pub sid_kind: u_int8_t,
    pub sid_authcount: u_int8_t,
    pub sid_authority: [u_int8_t; 6usize],
    pub sid_authorities: [u_int32_t; 16usize],
}
#[test]
fn bindgen_test_layout_ntsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<ntsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ntsid_t>(),
        72usize,
        concat!("Size of: ", stringify!(ntsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ntsid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ntsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_authcount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_authority) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_authorities) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authorities)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_identity_extlookup {
    pub el_seqno: u_int32_t,
    pub el_result: u_int32_t,
    pub el_flags: u_int32_t,
    pub el_info_pid: __darwin_pid_t,
    pub el_extend: u_int64_t,
    pub el_info_reserved_1: u_int32_t,
    pub el_uid: uid_t,
    pub el_uguid: guid_t,
    pub el_uguid_valid: u_int32_t,
    pub el_usid: ntsid_t,
    pub el_usid_valid: u_int32_t,
    pub el_gid: gid_t,
    pub el_gguid: guid_t,
    pub el_gguid_valid: u_int32_t,
    pub el_gsid: ntsid_t,
    pub el_gsid_valid: u_int32_t,
    pub el_member_valid: u_int32_t,
    pub el_sup_grp_cnt: u_int32_t,
    pub el_sup_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_kauth_identity_extlookup() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_identity_extlookup> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_identity_extlookup>(),
        304usize,
        concat!("Size of: ", stringify!(kauth_identity_extlookup))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_identity_extlookup>(),
        8usize,
        concat!("Alignment of ", stringify!(kauth_identity_extlookup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_seqno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_info_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_info_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_extend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_extend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_info_reserved_1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_info_reserved_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_uguid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uguid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_uguid_valid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uguid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_usid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_usid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_usid_valid) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_usid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gid) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gguid) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gguid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gguid_valid) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gguid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gsid) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gsid_valid) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gsid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_member_valid) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_member_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_sup_grp_cnt) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_sup_grp_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_sup_groups) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_sup_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kauth_cache_sizes {
    pub kcs_group_size: u_int32_t,
    pub kcs_id_size: u_int32_t,
}
#[test]
fn bindgen_test_layout_kauth_cache_sizes() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_cache_sizes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_cache_sizes>(),
        8usize,
        concat!("Size of: ", stringify!(kauth_cache_sizes))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_cache_sizes>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_cache_sizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kcs_group_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_cache_sizes),
            "::",
            stringify!(kcs_group_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kcs_id_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_cache_sizes),
            "::",
            stringify!(kcs_id_size)
        )
    );
}
pub type kauth_ace_rights_t = u_int32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_ace {
    pub ace_applicable: guid_t,
    pub ace_flags: u_int32_t,
    pub ace_rights: kauth_ace_rights_t,
}
#[test]
fn bindgen_test_layout_kauth_ace() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_ace> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_ace>(),
        24usize,
        concat!("Size of: ", stringify!(kauth_ace))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_ace>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_ace))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ace_applicable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_applicable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ace_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ace_rights) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_rights)
        )
    );
}
pub type kauth_ace_t = *mut kauth_ace;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_acl {
    pub acl_entrycount: u_int32_t,
    pub acl_flags: u_int32_t,
    pub acl_ace: [kauth_ace; 1usize],
}
#[test]
fn bindgen_test_layout_kauth_acl() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_acl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_acl>(),
        32usize,
        concat!("Size of: ", stringify!(kauth_acl))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_acl>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_acl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl_entrycount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_entrycount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl_ace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_ace)
        )
    );
}
pub type kauth_acl_t = *mut kauth_acl;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_filesec {
    pub fsec_magic: u_int32_t,
    pub fsec_owner: guid_t,
    pub fsec_group: guid_t,
    pub fsec_acl: kauth_acl,
}
#[test]
fn bindgen_test_layout_kauth_filesec() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_filesec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_filesec>(),
        68usize,
        concat!("Size of: ", stringify!(kauth_filesec))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_filesec>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_filesec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_owner) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_group) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_acl) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_acl)
        )
    );
}
pub type kauth_filesec_t = *mut kauth_filesec;
pub const acl_perm_t_ACL_READ_DATA: acl_perm_t = 2;
pub const acl_perm_t_ACL_LIST_DIRECTORY: acl_perm_t = 2;
pub const acl_perm_t_ACL_WRITE_DATA: acl_perm_t = 4;
pub const acl_perm_t_ACL_ADD_FILE: acl_perm_t = 4;
pub const acl_perm_t_ACL_EXECUTE: acl_perm_t = 8;
pub const acl_perm_t_ACL_SEARCH: acl_perm_t = 8;
pub const acl_perm_t_ACL_DELETE: acl_perm_t = 16;
pub const acl_perm_t_ACL_APPEND_DATA: acl_perm_t = 32;
pub const acl_perm_t_ACL_ADD_SUBDIRECTORY: acl_perm_t = 32;
pub const acl_perm_t_ACL_DELETE_CHILD: acl_perm_t = 64;
pub const acl_perm_t_ACL_READ_ATTRIBUTES: acl_perm_t = 128;
pub const acl_perm_t_ACL_WRITE_ATTRIBUTES: acl_perm_t = 256;
pub const acl_perm_t_ACL_READ_EXTATTRIBUTES: acl_perm_t = 512;
pub const acl_perm_t_ACL_WRITE_EXTATTRIBUTES: acl_perm_t = 1024;
pub const acl_perm_t_ACL_READ_SECURITY: acl_perm_t = 2048;
pub const acl_perm_t_ACL_WRITE_SECURITY: acl_perm_t = 4096;
pub const acl_perm_t_ACL_CHANGE_OWNER: acl_perm_t = 8192;
pub const acl_perm_t_ACL_SYNCHRONIZE: acl_perm_t = 1048576;
pub type acl_perm_t = ::std::os::raw::c_uint;
pub const acl_tag_t_ACL_UNDEFINED_TAG: acl_tag_t = 0;
pub const acl_tag_t_ACL_EXTENDED_ALLOW: acl_tag_t = 1;
pub const acl_tag_t_ACL_EXTENDED_DENY: acl_tag_t = 2;
pub type acl_tag_t = ::std::os::raw::c_uint;
pub const acl_type_t_ACL_TYPE_EXTENDED: acl_type_t = 256;
pub const acl_type_t_ACL_TYPE_ACCESS: acl_type_t = 0;
pub const acl_type_t_ACL_TYPE_DEFAULT: acl_type_t = 1;
pub const acl_type_t_ACL_TYPE_AFS: acl_type_t = 2;
pub const acl_type_t_ACL_TYPE_CODA: acl_type_t = 3;
pub const acl_type_t_ACL_TYPE_NTFS: acl_type_t = 4;
pub const acl_type_t_ACL_TYPE_NWFS: acl_type_t = 5;
pub type acl_type_t = ::std::os::raw::c_uint;
pub const acl_entry_id_t_ACL_FIRST_ENTRY: acl_entry_id_t = 0;
pub const acl_entry_id_t_ACL_NEXT_ENTRY: acl_entry_id_t = -1;
pub const acl_entry_id_t_ACL_LAST_ENTRY: acl_entry_id_t = -2;
pub type acl_entry_id_t = ::std::os::raw::c_int;
pub const acl_flag_t_ACL_FLAG_DEFER_INHERIT: acl_flag_t = 1;
pub const acl_flag_t_ACL_FLAG_NO_INHERIT: acl_flag_t = 131072;
pub const acl_flag_t_ACL_ENTRY_INHERITED: acl_flag_t = 16;
pub const acl_flag_t_ACL_ENTRY_FILE_INHERIT: acl_flag_t = 32;
pub const acl_flag_t_ACL_ENTRY_DIRECTORY_INHERIT: acl_flag_t = 64;
pub const acl_flag_t_ACL_ENTRY_LIMIT_INHERIT: acl_flag_t = 128;
pub const acl_flag_t_ACL_ENTRY_ONLY_INHERIT: acl_flag_t = 256;
pub type acl_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_permset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_flagset {
    _unused: [u8; 0],
}
pub type acl_t = *mut _acl;
pub type acl_entry_t = *mut _acl_entry;
pub type acl_permset_t = *mut _acl_permset;
pub type acl_flagset_t = *mut _acl_flagset;
pub type acl_permset_mask_t = u_int64_t;
extern "C" {
    pub fn acl_dup(acl: acl_t) -> acl_t;
}
extern "C" {
    pub fn acl_free(obj_p: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_init(count: ::std::os::raw::c_int) -> acl_t;
}
extern "C" {
    pub fn acl_copy_entry(dest_d: acl_entry_t, src_d: acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_create_entry(acl_p: *mut acl_t, entry_p: *mut acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_create_entry_np(
        acl_p: *mut acl_t,
        entry_p: *mut acl_entry_t,
        entry_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_entry(acl: acl_t, entry_d: acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_entry(
        acl: acl_t,
        entry_id: ::std::os::raw::c_int,
        entry_p: *mut acl_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid(acl: acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_fd_np(
        fd: ::std::os::raw::c_int,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_file_np(
        path: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_link_np(
        path: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_add_perm(permset_d: acl_permset_t, perm: acl_perm_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_calc_mask(acl_p: *mut acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_clear_perms(permset_d: acl_permset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_perm(permset_d: acl_permset_t, perm: acl_perm_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_perm_np(permset_d: acl_permset_t, perm: acl_perm_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_permset(
        entry_d: acl_entry_t,
        permset_p: *mut acl_permset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_permset(entry_d: acl_entry_t, permset_d: acl_permset_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_maximal_permset_mask_np(mask_p: *mut acl_permset_mask_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_permset_mask_np(
        entry_d: acl_entry_t,
        mask_p: *mut acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_permset_mask_np(
        entry_d: acl_entry_t,
        mask: acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_add_flag_np(flagset_d: acl_flagset_t, flag: acl_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_clear_flags_np(flagset_d: acl_flagset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_flag_np(flagset_d: acl_flagset_t, flag: acl_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_flag_np(flagset_d: acl_flagset_t, flag: acl_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_flagset_np(
        obj_p: *mut ::std::os::raw::c_void,
        flagset_p: *mut acl_flagset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_flagset_np(
        obj_p: *mut ::std::os::raw::c_void,
        flagset_d: acl_flagset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_qualifier(entry_d: acl_entry_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn acl_get_tag_type(
        entry_d: acl_entry_t,
        tag_type_p: *mut acl_tag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_qualifier(
        entry_d: acl_entry_t,
        tag_qualifier_p: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_tag_type(entry_d: acl_entry_t, tag_type: acl_tag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_def_file(path_p: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_fd(fd: ::std::os::raw::c_int) -> acl_t;
}
extern "C" {
    pub fn acl_get_fd_np(fd: ::std::os::raw::c_int, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_get_file(path_p: *const ::std::os::raw::c_char, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_get_link_np(path_p: *const ::std::os::raw::c_char, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_set_fd(fd: ::std::os::raw::c_int, acl: acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_fd_np(
        fd: ::std::os::raw::c_int,
        acl: acl_t,
        acl_type: acl_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_file(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_link_np(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_copy_ext(buf_p: *mut ::std::os::raw::c_void, acl: acl_t, size: isize) -> isize;
}
extern "C" {
    pub fn acl_copy_ext_native(
        buf_p: *mut ::std::os::raw::c_void,
        acl: acl_t,
        size: isize,
    ) -> isize;
}
extern "C" {
    pub fn acl_copy_int(buf_p: *const ::std::os::raw::c_void) -> acl_t;
}
extern "C" {
    pub fn acl_copy_int_native(buf_p: *const ::std::os::raw::c_void) -> acl_t;
}
extern "C" {
    pub fn acl_from_text(buf_p: *const ::std::os::raw::c_char) -> acl_t;
}
extern "C" {
    pub fn acl_size(acl: acl_t) -> isize;
}
extern "C" {
    pub fn acl_to_text(acl: acl_t, len_p: *mut isize) -> *mut ::std::os::raw::c_char;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_i386_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ebx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ecx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__edx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__edi) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esi) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ebp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__eflags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__eip) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cs) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__gs) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mmst_reg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mmst_reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mmst_rsrv) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_xmm_reg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__xmm_reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ymm_reg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ymm_reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_zmm_reg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__zmm_reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_opmask_reg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opmask_reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_i386_float_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fcw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fsw) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ftw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fop) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_dp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsrmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm5) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm6) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm7) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm0) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm2) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm5) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv4) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved1) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_i386_avx_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fcw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fsw) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ftw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fop) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_dp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsrmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm5) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm6) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm7) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm0) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm2) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm5) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv4) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved1) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__avx_reserved1) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh0) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh1) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh2) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh3) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh4) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh5) as usize - ptr as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh6) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh7) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_i386_avx512_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fcw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fsw) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ftw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fop) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_dp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsrmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm5) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm6) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm7) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm0) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm2) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm5) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv4) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved1) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__avx_reserved1) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh0) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh1) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh2) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh3) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh4) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh5) as usize - ptr as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh6) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh7) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k0) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k1) as usize - ptr as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k2) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k3) as usize - ptr as usize },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k4) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k5) as usize - ptr as usize },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k6) as usize - ptr as usize },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k7) as usize - ptr as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh0) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh1) as usize - ptr as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh2) as usize - ptr as usize },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh3) as usize - ptr as usize },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh4) as usize - ptr as usize },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh5) as usize - ptr as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh6) as usize - ptr as usize },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh7) as usize - ptr as usize },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_i386_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__trapno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpu) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__err) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__faultvaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr4) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr5) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr7) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __x86_instruction_state {
    pub __insn_stream_valid_bytes: ::std::os::raw::c_int,
    pub __insn_offset: ::std::os::raw::c_int,
    pub __out_of_synch: ::std::os::raw::c_int,
    pub __insn_bytes: [__uint8_t; 2380usize],
    pub __insn_cacheline: [__uint8_t; 64usize],
}
#[test]
fn bindgen_test_layout___x86_instruction_state() {
    const UNINIT: ::std::mem::MaybeUninit<__x86_instruction_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__x86_instruction_state>(),
        2456usize,
        concat!("Size of: ", stringify!(__x86_instruction_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__x86_instruction_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__x86_instruction_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__insn_stream_valid_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_stream_valid_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__insn_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__out_of_synch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__out_of_synch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__insn_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__insn_cacheline) as usize - ptr as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_cacheline)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __last_branch_record {
    pub __from_ip: __uint64_t,
    pub __to_ip: __uint64_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout___last_branch_record() {
    const UNINIT: ::std::mem::MaybeUninit<__last_branch_record> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__last_branch_record>(),
        24usize,
        concat!("Size of: ", stringify!(__last_branch_record))
    );
    assert_eq!(
        ::std::mem::align_of::<__last_branch_record>(),
        8usize,
        concat!("Alignment of ", stringify!(__last_branch_record))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__from_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_record),
            "::",
            stringify!(__from_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__to_ip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_record),
            "::",
            stringify!(__to_ip)
        )
    );
}
impl __last_branch_record {
    #[inline]
    pub fn __mispredict(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___mispredict(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tsx_abort(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___tsx_abort(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __in_tsx(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___in_tsx(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __cycle_count(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set___cycle_count(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __mispredict: __uint32_t,
        __tsx_abort: __uint32_t,
        __in_tsx: __uint32_t,
        __cycle_count: __uint32_t,
        __reserved: __uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __mispredict: u32 = unsafe { ::std::mem::transmute(__mispredict) };
            __mispredict as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __tsx_abort: u32 = unsafe { ::std::mem::transmute(__tsx_abort) };
            __tsx_abort as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __in_tsx: u32 = unsafe { ::std::mem::transmute(__in_tsx) };
            __in_tsx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 16u8, {
            let __cycle_count: u32 = unsafe { ::std::mem::transmute(__cycle_count) };
            __cycle_count as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __last_branch_state {
    pub __lbr_count: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __lbrs: [__last_branch_record; 32usize],
}
#[test]
fn bindgen_test_layout___last_branch_state() {
    const UNINIT: ::std::mem::MaybeUninit<__last_branch_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__last_branch_state>(),
        776usize,
        concat!("Size of: ", stringify!(__last_branch_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__last_branch_state>(),
        8usize,
        concat!("Alignment of ", stringify!(__last_branch_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lbr_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_state),
            "::",
            stringify!(__lbr_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lbrs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_state),
            "::",
            stringify!(__lbrs)
        )
    );
}
impl __last_branch_state {
    #[inline]
    pub fn __lbr_supported_tsx(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___lbr_supported_tsx(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __lbr_supported_cycle_count(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___lbr_supported_cycle_count(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __lbr_supported_tsx: __uint32_t,
        __lbr_supported_cycle_count: __uint32_t,
        __reserved: __uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __lbr_supported_tsx: u32 = unsafe { ::std::mem::transmute(__lbr_supported_tsx) };
            __lbr_supported_tsx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __lbr_supported_cycle_count: u32 =
                unsafe { ::std::mem::transmute(__lbr_supported_cycle_count) };
            __lbr_supported_cycle_count as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __x86_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___x86_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__x86_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__x86_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__x86_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__x86_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__x86_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rbx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rcx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rdx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rdi) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rsi) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rbp) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rsp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r8) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r9) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r10) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r11) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r12) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r13) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r14) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r15) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rip) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rflags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__gs) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_full_state64 {
    pub __ss64: __darwin_x86_thread_state64,
    pub __ds: __uint64_t,
    pub __es: __uint64_t,
    pub __ss: __uint64_t,
    pub __gsbase: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_full_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_thread_full_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_full_state64>(),
        200usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_full_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_full_state64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_x86_thread_full_state64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ds) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__gsbase) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__gsbase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_float_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fcw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fsw) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ftw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fop) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_dp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsrmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm5) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm6) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm7) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm0) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm2) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm5) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm8) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm9) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm10) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm11) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm12) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm13) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm14) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm15) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv4) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved1) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_avx_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fcw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fsw) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ftw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fop) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_dp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsrmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm5) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm6) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm7) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm0) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm2) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm5) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm8) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm9) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm10) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm11) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm12) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm13) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm14) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm15) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv4) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved1) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__avx_reserved1) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh0) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh1) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh2) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh3) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh4) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh5) as usize - ptr as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh6) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh7) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh8) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh9) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh10) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh11) as usize - ptr as usize },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh12) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh13) as usize - ptr as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh14) as usize - ptr as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh15) as usize - ptr as usize },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_avx512_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fcw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fsw) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ftw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_fop) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_dp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_mxcsrmask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm5) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm6) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_stmm7) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm0) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm2) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm5) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm8) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm9) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm10) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm11) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm12) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm13) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm14) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_xmm15) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_rsrv4) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_reserved1) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__avx_reserved1) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh0) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh1) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh2) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh3) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh4) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh5) as usize - ptr as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh6) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh7) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh8) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh9) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh10) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh11) as usize - ptr as usize },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh12) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh13) as usize - ptr as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh14) as usize - ptr as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_ymmh15) as usize - ptr as usize },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k0) as usize - ptr as usize },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k1) as usize - ptr as usize },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k2) as usize - ptr as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k3) as usize - ptr as usize },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k4) as usize - ptr as usize },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k5) as usize - ptr as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k6) as usize - ptr as usize },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_k7) as usize - ptr as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh0) as usize - ptr as usize },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh1) as usize - ptr as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh2) as usize - ptr as usize },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh3) as usize - ptr as usize },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh4) as usize - ptr as usize },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh5) as usize - ptr as usize },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh6) as usize - ptr as usize },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh7) as usize - ptr as usize },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh8) as usize - ptr as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh9) as usize - ptr as usize },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh10) as usize - ptr as usize },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh11) as usize - ptr as usize },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh12) as usize - ptr as usize },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh13) as usize - ptr as usize },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh14) as usize - ptr as usize },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmmh15) as usize - ptr as usize },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm16) as usize - ptr as usize },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm17) as usize - ptr as usize },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm18) as usize - ptr as usize },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm19) as usize - ptr as usize },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm20) as usize - ptr as usize },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm21) as usize - ptr as usize },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm22) as usize - ptr as usize },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm23) as usize - ptr as usize },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm24) as usize - ptr as usize },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm25) as usize - ptr as usize },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm26) as usize - ptr as usize },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm27) as usize - ptr as usize },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm28) as usize - ptr as usize },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm29) as usize - ptr as usize },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm30) as usize - ptr as usize },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpu_zmm31) as usize - ptr as usize },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__trapno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpu) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__err) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__faultvaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr5) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr6) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dr7) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_x86_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext_avx32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext_avx512_32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64_full() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64_full> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64_full>(),
        744usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext_avx64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext_avx64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64_full() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext_avx64_full> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),
        1064usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext_avx512_64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext_avx512_64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64_full() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext_avx512_64_full> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64_full>(),
        2664usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64_full>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_mcontext_avx512_64_full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
pub type au_ctlmode_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_tid {
    pub port: dev_t,
    pub machine: u_int32_t,
}
#[test]
fn bindgen_test_layout_au_tid() {
    const UNINIT: ::std::mem::MaybeUninit<au_tid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_tid>(),
        8usize,
        concat!("Size of: ", stringify!(au_tid))
    );
    assert_eq!(
        ::std::mem::align_of::<au_tid>(),
        4usize,
        concat!("Alignment of ", stringify!(au_tid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_tid),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).machine) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(au_tid),
            "::",
            stringify!(machine)
        )
    );
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_tid_addr {
    pub at_port: dev_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
#[test]
fn bindgen_test_layout_au_tid_addr() {
    const UNINIT: ::std::mem::MaybeUninit<au_tid_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_tid_addr>(),
        24usize,
        concat!("Size of: ", stringify!(au_tid_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<au_tid_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(au_tid_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).at_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_tid_addr),
            "::",
            stringify!(at_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).at_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(au_tid_addr),
            "::",
            stringify!(at_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).at_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(au_tid_addr),
            "::",
            stringify!(at_addr)
        )
    );
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_mask {
    pub am_success: ::std::os::raw::c_uint,
    pub am_failure: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_au_mask() {
    const UNINIT: ::std::mem::MaybeUninit<au_mask> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_mask>(),
        8usize,
        concat!("Size of: ", stringify!(au_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<au_mask>(),
        4usize,
        concat!("Alignment of ", stringify!(au_mask))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_mask),
            "::",
            stringify!(am_success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_failure) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(au_mask),
            "::",
            stringify!(am_failure)
        )
    );
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditinfo() {
    const UNINIT: ::std::mem::MaybeUninit<auditinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<auditinfo>(),
        24usize,
        concat!("Size of: ", stringify!(auditinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<auditinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(auditinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_auid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo),
            "::",
            stringify!(ai_auid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo),
            "::",
            stringify!(ai_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_termid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo),
            "::",
            stringify!(ai_termid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_asid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo),
            "::",
            stringify!(ai_asid)
        )
    );
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditinfo_addr() {
    const UNINIT: ::std::mem::MaybeUninit<auditinfo_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<auditinfo_addr>(),
        48usize,
        concat!("Size of: ", stringify!(auditinfo_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<auditinfo_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(auditinfo_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_auid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo_addr),
            "::",
            stringify!(ai_auid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo_addr),
            "::",
            stringify!(ai_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_termid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo_addr),
            "::",
            stringify!(ai_termid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_asid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo_addr),
            "::",
            stringify!(ai_asid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(auditinfo_addr),
            "::",
            stringify!(ai_flags)
        )
    );
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditpinfo() {
    const UNINIT: ::std::mem::MaybeUninit<auditpinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<auditpinfo>(),
        28usize,
        concat!("Size of: ", stringify!(auditpinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<auditpinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(auditpinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo),
            "::",
            stringify!(ap_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_auid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo),
            "::",
            stringify!(ap_auid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo),
            "::",
            stringify!(ap_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_termid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo),
            "::",
            stringify!(ap_termid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_asid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo),
            "::",
            stringify!(ap_asid)
        )
    );
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditpinfo_addr() {
    const UNINIT: ::std::mem::MaybeUninit<auditpinfo_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<auditpinfo_addr>(),
        56usize,
        concat!("Size of: ", stringify!(auditpinfo_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<auditpinfo_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(auditpinfo_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo_addr),
            "::",
            stringify!(ap_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_auid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo_addr),
            "::",
            stringify!(ap_auid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo_addr),
            "::",
            stringify!(ap_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_termid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo_addr),
            "::",
            stringify!(ap_termid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_asid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo_addr),
            "::",
            stringify!(ap_asid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(auditpinfo_addr),
            "::",
            stringify!(ap_flags)
        )
    );
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
#[test]
fn bindgen_test_layout_au_session() {
    const UNINIT: ::std::mem::MaybeUninit<au_session> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_session>(),
        16usize,
        concat!("Size of: ", stringify!(au_session))
    );
    assert_eq!(
        ::std::mem::align_of::<au_session>(),
        8usize,
        concat!("Alignment of ", stringify!(au_session))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_aia_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_session),
            "::",
            stringify!(as_aia_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(au_session),
            "::",
            stringify!(as_mask)
        )
    );
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_expire_after {
    pub age: time_t,
    pub size: usize,
    pub op_type: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_au_expire_after() {
    const UNINIT: ::std::mem::MaybeUninit<au_expire_after> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_expire_after>(),
        24usize,
        concat!("Size of: ", stringify!(au_expire_after))
    );
    assert_eq!(
        ::std::mem::align_of::<au_expire_after>(),
        8usize,
        concat!("Alignment of ", stringify!(au_expire_after))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_expire_after),
            "::",
            stringify!(age)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(au_expire_after),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(au_expire_after),
            "::",
            stringify!(op_type)
        )
    );
}
pub type au_expire_after_t = au_expire_after;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_qctrl {
    pub aq_hiwater: ::std::os::raw::c_int,
    pub aq_lowater: ::std::os::raw::c_int,
    pub aq_bufsz: ::std::os::raw::c_int,
    pub aq_delay: ::std::os::raw::c_int,
    pub aq_minfree: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_au_qctrl() {
    const UNINIT: ::std::mem::MaybeUninit<au_qctrl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_qctrl>(),
        20usize,
        concat!("Size of: ", stringify!(au_qctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<au_qctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(au_qctrl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aq_hiwater) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_qctrl),
            "::",
            stringify!(aq_hiwater)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aq_lowater) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(au_qctrl),
            "::",
            stringify!(aq_lowater)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aq_bufsz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(au_qctrl),
            "::",
            stringify!(aq_bufsz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aq_delay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(au_qctrl),
            "::",
            stringify!(aq_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aq_minfree) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(au_qctrl),
            "::",
            stringify!(aq_minfree)
        )
    );
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_stat {
    pub as_version: ::std::os::raw::c_uint,
    pub as_numevent: ::std::os::raw::c_uint,
    pub as_generated: ::std::os::raw::c_int,
    pub as_nonattrib: ::std::os::raw::c_int,
    pub as_kernel: ::std::os::raw::c_int,
    pub as_audit: ::std::os::raw::c_int,
    pub as_auditctl: ::std::os::raw::c_int,
    pub as_enqueue: ::std::os::raw::c_int,
    pub as_written: ::std::os::raw::c_int,
    pub as_wblocked: ::std::os::raw::c_int,
    pub as_rblocked: ::std::os::raw::c_int,
    pub as_dropped: ::std::os::raw::c_int,
    pub as_totalsize: ::std::os::raw::c_int,
    pub as_memused: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_audit_stat() {
    const UNINIT: ::std::mem::MaybeUninit<audit_stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audit_stat>(),
        56usize,
        concat!("Size of: ", stringify!(audit_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_numevent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_numevent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_generated) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_generated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_nonattrib) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_nonattrib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_kernel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_kernel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_audit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_auditctl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_auditctl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_enqueue) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_enqueue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_written) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_written)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_wblocked) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_wblocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_rblocked) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_rblocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_dropped) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_dropped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_totalsize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_totalsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_memused) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_stat),
            "::",
            stringify!(as_memused)
        )
    );
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
#[test]
fn bindgen_test_layout_audit_fstat() {
    const UNINIT: ::std::mem::MaybeUninit<audit_fstat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audit_fstat>(),
        16usize,
        concat!("Size of: ", stringify!(audit_fstat))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_fstat>(),
        8usize,
        concat!("Alignment of ", stringify!(audit_fstat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_filesz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_fstat),
            "::",
            stringify!(af_filesz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_currsz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_fstat),
            "::",
            stringify!(af_currsz)
        )
    );
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
#[test]
fn bindgen_test_layout_au_evclass_map() {
    const UNINIT: ::std::mem::MaybeUninit<au_evclass_map> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<au_evclass_map>(),
        8usize,
        concat!("Size of: ", stringify!(au_evclass_map))
    );
    assert_eq!(
        ::std::mem::align_of::<au_evclass_map>(),
        4usize,
        concat!("Alignment of ", stringify!(au_evclass_map))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ec_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(au_evclass_map),
            "::",
            stringify!(ec_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ec_class) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(au_evclass_map),
            "::",
            stringify!(ec_class)
        )
    );
}
pub type au_evclass_map_t = au_evclass_map;
pub const audit_session_flags_AU_SESSION_FLAG_IS_INITIAL: audit_session_flags = 1;
pub const audit_session_flags_AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS: audit_session_flags = 16;
pub const audit_session_flags_AU_SESSION_FLAG_HAS_TTY: audit_session_flags = 32;
pub const audit_session_flags_AU_SESSION_FLAG_IS_REMOTE: audit_session_flags = 4096;
pub const audit_session_flags_AU_SESSION_FLAG_HAS_CONSOLE_ACCESS: audit_session_flags = 8192;
pub const audit_session_flags_AU_SESSION_FLAG_HAS_AUTHENTICATED: audit_session_flags = 16384;
pub type audit_session_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn audit(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn auditon(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn auditctl(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getauid(arg1: *mut au_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setauid(arg1: *const au_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getaudit_addr(
        arg1: *mut auditinfo_addr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setaudit_addr(
        arg1: *const auditinfo_addr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getaudit(arg1: *mut auditinfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setaudit(arg1: *const auditinfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audit_session_self() -> mach_port_name_t;
}
extern "C" {
    pub fn audit_session_join(port: mach_port_name_t) -> au_asid_t;
}
extern "C" {
    pub fn audit_session_port(
        asid: au_asid_t,
        portname: *mut mach_port_name_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cred {
    _unused: [u8; 0],
}
pub type kauth_cred_t = *mut ucred;
pub type posix_cred_t = *mut posix_cred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::std::os::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_xucred() {
    const UNINIT: ::std::mem::MaybeUninit<xucred> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xucred>(),
        76usize,
        concat!("Size of: ", stringify!(xucred))
    );
    assert_eq!(
        ::std::mem::align_of::<xucred>(),
        4usize,
        concat!("Alignment of ", stringify!(xucred))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xucred),
            "::",
            stringify!(cr_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xucred),
            "::",
            stringify!(cr_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_ngroups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xucred),
            "::",
            stringify!(cr_ngroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_groups) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xucred),
            "::",
            stringify!(cr_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    const UNINIT: ::std::mem::MaybeUninit<timeval64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    const UNINIT: ::std::mem::MaybeUninit<clockinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tickadj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tickadj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stathz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profhz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_select$1050"]
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
pub type text_encoding_t = u_int32_t;
pub type fsobj_type_t = u_int32_t;
pub type fsobj_tag_t = u_int32_t;
pub type fsfile_type_t = u_int32_t;
pub type fsvolid_t = u_int32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsobj_id {
    pub fid_objno: u_int32_t,
    pub fid_generation: u_int32_t,
}
#[test]
fn bindgen_test_layout_fsobj_id() {
    const UNINIT: ::std::mem::MaybeUninit<fsobj_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fsobj_id>(),
        8usize,
        concat!("Size of: ", stringify!(fsobj_id))
    );
    assert_eq!(
        ::std::mem::align_of::<fsobj_id>(),
        4usize,
        concat!("Alignment of ", stringify!(fsobj_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fid_objno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsobj_id),
            "::",
            stringify!(fid_objno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fid_generation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fsobj_id),
            "::",
            stringify!(fid_generation)
        )
    );
}
pub type fsobj_id_t = fsobj_id;
pub type attrgroup_t = u_int32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attrlist {
    pub bitmapcount: u_short,
    pub reserved: u_int16_t,
    pub commonattr: attrgroup_t,
    pub volattr: attrgroup_t,
    pub dirattr: attrgroup_t,
    pub fileattr: attrgroup_t,
    pub forkattr: attrgroup_t,
}
#[test]
fn bindgen_test_layout_attrlist() {
    const UNINIT: ::std::mem::MaybeUninit<attrlist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attrlist>(),
        24usize,
        concat!("Size of: ", stringify!(attrlist))
    );
    assert_eq!(
        ::std::mem::align_of::<attrlist>(),
        4usize,
        concat!("Alignment of ", stringify!(attrlist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmapcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(bitmapcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commonattr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(commonattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volattr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(volattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirattr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(dirattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileattr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(fileattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forkattr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(attrlist),
            "::",
            stringify!(forkattr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute_set {
    pub commonattr: attrgroup_t,
    pub volattr: attrgroup_t,
    pub dirattr: attrgroup_t,
    pub fileattr: attrgroup_t,
    pub forkattr: attrgroup_t,
}
#[test]
fn bindgen_test_layout_attribute_set() {
    const UNINIT: ::std::mem::MaybeUninit<attribute_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attribute_set>(),
        20usize,
        concat!("Size of: ", stringify!(attribute_set))
    );
    assert_eq!(
        ::std::mem::align_of::<attribute_set>(),
        4usize,
        concat!("Alignment of ", stringify!(attribute_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commonattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_set),
            "::",
            stringify!(commonattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volattr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_set),
            "::",
            stringify!(volattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirattr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_set),
            "::",
            stringify!(dirattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileattr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_set),
            "::",
            stringify!(fileattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forkattr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_set),
            "::",
            stringify!(forkattr)
        )
    );
}
pub type attribute_set_t = attribute_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attrreference {
    pub attr_dataoffset: i32,
    pub attr_length: u_int32_t,
}
#[test]
fn bindgen_test_layout_attrreference() {
    const UNINIT: ::std::mem::MaybeUninit<attrreference> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attrreference>(),
        8usize,
        concat!("Size of: ", stringify!(attrreference))
    );
    assert_eq!(
        ::std::mem::align_of::<attrreference>(),
        4usize,
        concat!("Alignment of ", stringify!(attrreference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr_dataoffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attrreference),
            "::",
            stringify!(attr_dataoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(attrreference),
            "::",
            stringify!(attr_length)
        )
    );
}
pub type attrreference_t = attrreference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diskextent {
    pub startblock: u_int32_t,
    pub blockcount: u_int32_t,
}
#[test]
fn bindgen_test_layout_diskextent() {
    const UNINIT: ::std::mem::MaybeUninit<diskextent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<diskextent>(),
        8usize,
        concat!("Size of: ", stringify!(diskextent))
    );
    assert_eq!(
        ::std::mem::align_of::<diskextent>(),
        4usize,
        concat!("Alignment of ", stringify!(diskextent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startblock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diskextent),
            "::",
            stringify!(startblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockcount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(diskextent),
            "::",
            stringify!(blockcount)
        )
    );
}
pub type extentrecord = [diskextent; 8usize];
pub type vol_capabilities_set_t = [u_int32_t; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vol_capabilities_attr {
    pub capabilities: vol_capabilities_set_t,
    pub valid: vol_capabilities_set_t,
}
#[test]
fn bindgen_test_layout_vol_capabilities_attr() {
    const UNINIT: ::std::mem::MaybeUninit<vol_capabilities_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vol_capabilities_attr>(),
        32usize,
        concat!("Size of: ", stringify!(vol_capabilities_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<vol_capabilities_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(vol_capabilities_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vol_capabilities_attr),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vol_capabilities_attr),
            "::",
            stringify!(valid)
        )
    );
}
pub type vol_capabilities_attr_t = vol_capabilities_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vol_attributes_attr {
    pub validattr: attribute_set_t,
    pub nativeattr: attribute_set_t,
}
#[test]
fn bindgen_test_layout_vol_attributes_attr() {
    const UNINIT: ::std::mem::MaybeUninit<vol_attributes_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vol_attributes_attr>(),
        40usize,
        concat!("Size of: ", stringify!(vol_attributes_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<vol_attributes_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(vol_attributes_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vol_attributes_attr),
            "::",
            stringify!(validattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nativeattr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vol_attributes_attr),
            "::",
            stringify!(nativeattr)
        )
    );
}
pub type vol_attributes_attr_t = vol_attributes_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    pub returnattrs: *mut attrlist,
    pub returnbuffer: *mut ::std::os::raw::c_void,
    pub returnbuffersize: usize,
    pub maxmatches: u_long,
    pub timelimit: timeval,
    pub searchparams1: *mut ::std::os::raw::c_void,
    pub sizeofsearchparams1: usize,
    pub searchparams2: *mut ::std::os::raw::c_void,
    pub sizeofsearchparams2: usize,
    pub searchattrs: attrlist,
}
#[test]
fn bindgen_test_layout_fssearchblock() {
    const UNINIT: ::std::mem::MaybeUninit<fssearchblock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fssearchblock>(),
        104usize,
        concat!("Size of: ", stringify!(fssearchblock))
    );
    assert_eq!(
        ::std::mem::align_of::<fssearchblock>(),
        8usize,
        concat!("Alignment of ", stringify!(fssearchblock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnattrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(returnattrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnbuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(returnbuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnbuffersize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(returnbuffersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxmatches) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(maxmatches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timelimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(timelimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).searchparams1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(searchparams1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofsearchparams1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(sizeofsearchparams1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).searchparams2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(searchparams2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofsearchparams2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(sizeofsearchparams2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).searchattrs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fssearchblock),
            "::",
            stringify!(searchattrs)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    pub ss_union_flags: u32,
    pub ss_union_layer: u32,
    pub ss_fsstate: [u_char; 548usize],
}
#[test]
fn bindgen_test_layout_searchstate() {
    const UNINIT: ::std::mem::MaybeUninit<searchstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<searchstate>(),
        556usize,
        concat!("Size of: ", stringify!(searchstate))
    );
    assert_eq!(
        ::std::mem::align_of::<searchstate>(),
        1usize,
        concat!("Alignment of ", stringify!(searchstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_union_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(searchstate),
            "::",
            stringify!(ss_union_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_union_layer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(searchstate),
            "::",
            stringify!(ss_union_layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_fsstate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(searchstate),
            "::",
            stringify!(ss_fsstate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsid {
    pub val: [i32; 2usize],
}
#[test]
fn bindgen_test_layout_fsid() {
    const UNINIT: ::std::mem::MaybeUninit<fsid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fsid>(),
        8usize,
        concat!("Size of: ", stringify!(fsid))
    );
    assert_eq!(
        ::std::mem::align_of::<fsid>(),
        4usize,
        concat!("Alignment of ", stringify!(fsid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fsid), "::", stringify!(val))
    );
}
pub type fsid_t = fsid;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct secure_boot_cryptex_args {
    pub sbc_version: u_int32_t,
    pub sbc_4cc: u_int32_t,
    pub sbc_authentic_manifest_fd: ::std::os::raw::c_int,
    pub sbc_user_manifest_fd: ::std::os::raw::c_int,
    pub sbc_payload_fd: ::std::os::raw::c_int,
    pub sbc_flags: u_int64_t,
}
#[test]
fn bindgen_test_layout_secure_boot_cryptex_args() {
    const UNINIT: ::std::mem::MaybeUninit<secure_boot_cryptex_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<secure_boot_cryptex_args>(),
        28usize,
        concat!("Size of: ", stringify!(secure_boot_cryptex_args))
    );
    assert_eq!(
        ::std::mem::align_of::<secure_boot_cryptex_args>(),
        4usize,
        concat!("Alignment of ", stringify!(secure_boot_cryptex_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_boot_cryptex_args),
            "::",
            stringify!(sbc_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_4cc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_boot_cryptex_args),
            "::",
            stringify!(sbc_4cc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_authentic_manifest_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_boot_cryptex_args),
            "::",
            stringify!(sbc_authentic_manifest_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_user_manifest_fd) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_boot_cryptex_args),
            "::",
            stringify!(sbc_user_manifest_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_payload_fd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_boot_cryptex_args),
            "::",
            stringify!(sbc_payload_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_boot_cryptex_args),
            "::",
            stringify!(sbc_flags)
        )
    );
}
pub type secure_boot_cryptex_args_t = secure_boot_cryptex_args;
#[repr(C)]
#[derive(Copy, Clone)]
pub union graft_args {
    pub max_size: [u_int8_t; 512usize],
    pub sbc_args: secure_boot_cryptex_args_t,
}
#[test]
fn bindgen_test_layout_graft_args() {
    const UNINIT: ::std::mem::MaybeUninit<graft_args> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<graft_args>(),
        512usize,
        concat!("Size of: ", stringify!(graft_args))
    );
    assert_eq!(
        ::std::mem::align_of::<graft_args>(),
        4usize,
        concat!("Alignment of ", stringify!(graft_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(graft_args),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbc_args) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(graft_args),
            "::",
            stringify!(sbc_args)
        )
    );
}
pub type graftdmg_args_un = graft_args;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
pub type mount_t = *mut mount;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vnode_t = *mut vnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statfs64 {
    pub f_bsize: u32,
    pub f_iosize: i32,
    pub f_blocks: u64,
    pub f_bfree: u64,
    pub f_bavail: u64,
    pub f_files: u64,
    pub f_ffree: u64,
    pub f_fsid: fsid_t,
    pub f_owner: uid_t,
    pub f_type: u32,
    pub f_flags: u32,
    pub f_fssubtype: u32,
    pub f_fstypename: [::std::os::raw::c_char; 16usize],
    pub f_mntonname: [::std::os::raw::c_char; 1024usize],
    pub f_mntfromname: [::std::os::raw::c_char; 1024usize],
    pub f_flags_ext: u32,
    pub f_reserved: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_statfs64() {
    const UNINIT: ::std::mem::MaybeUninit<statfs64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<statfs64>(),
        2168usize,
        concat!("Size of: ", stringify!(statfs64))
    );
    assert_eq!(
        ::std::mem::align_of::<statfs64>(),
        8usize,
        concat!("Alignment of ", stringify!(statfs64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_iosize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_iosize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_blocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bfree) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bavail) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_files) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_ffree) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fsid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_owner) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_type) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fssubtype) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_fssubtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fstypename) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_fstypename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_mntonname) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_mntonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_mntfromname) as usize - ptr as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_mntfromname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_flags_ext) as usize - ptr as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_flags_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_reserved) as usize - ptr as usize },
        2140usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs64),
            "::",
            stringify!(f_reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statfs {
    pub f_bsize: u32,
    pub f_iosize: i32,
    pub f_blocks: u64,
    pub f_bfree: u64,
    pub f_bavail: u64,
    pub f_files: u64,
    pub f_ffree: u64,
    pub f_fsid: fsid_t,
    pub f_owner: uid_t,
    pub f_type: u32,
    pub f_flags: u32,
    pub f_fssubtype: u32,
    pub f_fstypename: [::std::os::raw::c_char; 16usize],
    pub f_mntonname: [::std::os::raw::c_char; 1024usize],
    pub f_mntfromname: [::std::os::raw::c_char; 1024usize],
    pub f_flags_ext: u32,
    pub f_reserved: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_statfs() {
    const UNINIT: ::std::mem::MaybeUninit<statfs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<statfs>(),
        2168usize,
        concat!("Size of: ", stringify!(statfs))
    );
    assert_eq!(
        ::std::mem::align_of::<statfs>(),
        8usize,
        concat!("Alignment of ", stringify!(statfs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_iosize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_iosize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_blocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bfree) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bavail) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_files) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_ffree) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fsid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_owner) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_type) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fssubtype) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_fssubtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fstypename) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_fstypename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_mntonname) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_mntonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_mntfromname) as usize - ptr as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_mntfromname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_flags_ext) as usize - ptr as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_flags_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_reserved) as usize - ptr as usize },
        2140usize,
        concat!(
            "Offset of field: ",
            stringify!(statfs),
            "::",
            stringify!(f_reserved)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct vfsstatfs {
    pub f_bsize: u32,
    pub f_iosize: usize,
    pub f_blocks: u64,
    pub f_bfree: u64,
    pub f_bavail: u64,
    pub f_bused: u64,
    pub f_files: u64,
    pub f_ffree: u64,
    pub f_fsid: fsid_t,
    pub f_owner: uid_t,
    pub f_flags: u64,
    pub f_fstypename: [::std::os::raw::c_char; 16usize],
    pub f_mntonname: [::std::os::raw::c_char; 1024usize],
    pub f_mntfromname: [::std::os::raw::c_char; 1024usize],
    pub f_fssubtype: u32,
    pub f_reserved: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_vfsstatfs() {
    const UNINIT: ::std::mem::MaybeUninit<vfsstatfs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfsstatfs>(),
        2164usize,
        concat!("Size of: ", stringify!(vfsstatfs))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsstatfs>(),
        4usize,
        concat!("Alignment of ", stringify!(vfsstatfs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_iosize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_iosize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_blocks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bfree) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bavail) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bused) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_bused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_files) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_ffree) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fsid) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_owner) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fstypename) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_fstypename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_mntonname) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_mntonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_mntfromname) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_mntfromname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fssubtype) as usize - ptr as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_fssubtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_reserved) as usize - ptr as usize },
        2148usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsstatfs),
            "::",
            stringify!(f_reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsconf {
    pub vfc_reserved1: u32,
    pub vfc_name: [::std::os::raw::c_char; 15usize],
    pub vfc_typenum: ::std::os::raw::c_int,
    pub vfc_refcount: ::std::os::raw::c_int,
    pub vfc_flags: ::std::os::raw::c_int,
    pub vfc_reserved2: u32,
    pub vfc_reserved3: u32,
}
#[test]
fn bindgen_test_layout_vfsconf() {
    const UNINIT: ::std::mem::MaybeUninit<vfsconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfsconf>(),
        40usize,
        concat!("Size of: ", stringify!(vfsconf))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsconf>(),
        4usize,
        concat!("Alignment of ", stringify!(vfsconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_typenum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_typenum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_refcount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_reserved2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc_reserved3) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsconf),
            "::",
            stringify!(vfc_reserved3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsidctl {
    pub vc_vers: ::std::os::raw::c_int,
    pub vc_fsid: fsid_t,
    pub vc_ptr: *mut ::std::os::raw::c_void,
    pub vc_len: usize,
    pub vc_spare: [u_int32_t; 12usize],
}
#[test]
fn bindgen_test_layout_vfsidctl() {
    const UNINIT: ::std::mem::MaybeUninit<vfsidctl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfsidctl>(),
        80usize,
        concat!("Size of: ", stringify!(vfsidctl))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsidctl>(),
        8usize,
        concat!("Alignment of ", stringify!(vfsidctl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc_vers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsidctl),
            "::",
            stringify!(vc_vers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc_fsid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsidctl),
            "::",
            stringify!(vc_fsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc_ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsidctl),
            "::",
            stringify!(vc_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsidctl),
            "::",
            stringify!(vc_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc_spare) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsidctl),
            "::",
            stringify!(vc_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsquery {
    pub vq_flags: u_int32_t,
    pub vq_spare: [u_int32_t; 31usize],
}
#[test]
fn bindgen_test_layout_vfsquery() {
    const UNINIT: ::std::mem::MaybeUninit<vfsquery> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfsquery>(),
        128usize,
        concat!("Size of: ", stringify!(vfsquery))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsquery>(),
        4usize,
        concat!("Alignment of ", stringify!(vfsquery))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vq_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsquery),
            "::",
            stringify!(vq_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vq_spare) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsquery),
            "::",
            stringify!(vq_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_server {
    pub vs_minutes: i32,
    pub vs_server_name: [u_int8_t; 768usize],
}
#[test]
fn bindgen_test_layout_vfs_server() {
    const UNINIT: ::std::mem::MaybeUninit<vfs_server> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfs_server>(),
        772usize,
        concat!("Size of: ", stringify!(vfs_server))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_server>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_server))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vs_minutes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_server),
            "::",
            stringify!(vs_minutes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vs_server_name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_server),
            "::",
            stringify!(vs_server_name)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct netfs_status {
    pub ns_status: u_int32_t,
    pub ns_mountopts: [::std::os::raw::c_char; 512usize],
    pub ns_waittime: u32,
    pub ns_threadcount: u32,
    pub ns_threadids: __IncompleteArrayField<u64>,
}
#[test]
fn bindgen_test_layout_netfs_status() {
    const UNINIT: ::std::mem::MaybeUninit<netfs_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<netfs_status>(),
        528usize,
        concat!("Size of: ", stringify!(netfs_status))
    );
    assert_eq!(
        ::std::mem::align_of::<netfs_status>(),
        8usize,
        concat!("Alignment of ", stringify!(netfs_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netfs_status),
            "::",
            stringify!(ns_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_mountopts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netfs_status),
            "::",
            stringify!(ns_mountopts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_waittime) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(netfs_status),
            "::",
            stringify!(ns_waittime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_threadcount) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(netfs_status),
            "::",
            stringify!(ns_threadcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_threadids) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(netfs_status),
            "::",
            stringify!(ns_threadids)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fhandle {
    pub fh_len: ::std::os::raw::c_uint,
    pub fh_data: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_fhandle() {
    const UNINIT: ::std::mem::MaybeUninit<fhandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fhandle>(),
        132usize,
        concat!("Size of: ", stringify!(fhandle))
    );
    assert_eq!(
        ::std::mem::align_of::<fhandle>(),
        4usize,
        concat!("Alignment of ", stringify!(fhandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fh_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fhandle),
            "::",
            stringify!(fh_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fh_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fhandle),
            "::",
            stringify!(fh_data)
        )
    );
}
pub type fhandle_t = fhandle;
pub const graftdmg_type_t_GRAFTDMG_CRYPTEX_BOOT: graftdmg_type_t = 1;
pub const graftdmg_type_t_GRAFTDMG_CRYPTEX_PREBOOT: graftdmg_type_t = 2;
pub const graftdmg_type_t_GRAFTDMG_CRYPTEX_DOWNLEVEL: graftdmg_type_t = 3;
pub const graftdmg_type_t_GRAFTDMG_CRYPTEX_PDI_NONCE: graftdmg_type_t = 6;
pub const graftdmg_type_t_GRAFTDMG_CRYPTEX_EFFECTIVE_AP: graftdmg_type_t = 7;
pub const graftdmg_type_t_GRAFTDMG_CRYPTEX_MAX: graftdmg_type_t = 7;
pub type graftdmg_type_t = u32;
pub const cryptex_auth_type_t_CRYPTEX1_AUTH_ENV_GENERIC: cryptex_auth_type_t = 4;
pub const cryptex_auth_type_t_CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL: cryptex_auth_type_t = 5;
pub const cryptex_auth_type_t_CRYPTEX_AUTH_PDI_NONCE: cryptex_auth_type_t = 6;
pub const cryptex_auth_type_t_CRYPTEX_AUTH_MAX: cryptex_auth_type_t = 7;
pub type cryptex_auth_type_t = u32;
extern "C" {
    pub fn fhopen(arg1: *const fhandle, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstatfs$INODE64"]
    pub fn fstatfs(arg1: ::std::os::raw::c_int, arg2: *mut statfs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatfs64(arg1: ::std::os::raw::c_int, arg2: *mut statfs64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getfh(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fhandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getfsstat$INODE64"]
    pub fn getfsstat(
        arg1: *mut statfs,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getfsstat64(
        arg1: *mut statfs64,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getmntinfo$INODE64"]
    pub fn getmntinfo(arg1: *mut *mut statfs, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getmntinfo_r_np$INODE64"]
    pub fn getmntinfo_r_np(
        arg1: *mut *mut statfs,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmntinfo64(
        arg1: *mut *mut statfs64,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mount(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmount(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_statfs$INODE64"]
    pub fn statfs(arg1: *const ::std::os::raw::c_char, arg2: *mut statfs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn statfs64(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut statfs64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unmount(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getvfsbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut vfsconf,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[test]
fn bindgen_test_layout_ostat() {
    const UNINIT: ::std::mem::MaybeUninit<ostat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ostat>(),
        96usize,
        concat!("Size of: ", stringify!(ostat))
    );
    assert_eq!(
        ::std::mem::align_of::<ostat>(),
        8usize,
        concat!("Alignment of ", stringify!(ostat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_birthtimespec) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_birthtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_lspare) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_lspare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_qspare) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_qspare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat64() {
    const UNINIT: ::std::mem::MaybeUninit<stat64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat64>(),
        144usize,
        concat!("Size of: ", stringify!(stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(stat64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_birthtimespec) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_birthtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_lspare) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_lspare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_qspare) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_qspare)
        )
    );
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstat$INODE64"]
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lstat$INODE64"]
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_stat$INODE64"]
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstatat$INODE64"]
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
extern "C" {
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstatx_np$INODE64"]
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lstatx_np$INODE64"]
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_statx_np$INODE64"]
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatx64_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat64,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstatx64_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat64,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn statx64_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat64,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat64(arg1: ::std::os::raw::c_int, arg2: *mut stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat64(arg1: *const ::std::os::raw::c_char, arg2: *mut stat64)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stat64(arg1: *const ::std::os::raw::c_char, arg2: *mut stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getxattr(
        path: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
        size: usize,
        position: u_int32_t,
        options: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn fgetxattr(
        fd: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
        size: usize,
        position: u_int32_t,
        options: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn setxattr(
        path: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_void,
        size: usize,
        position: u_int32_t,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetxattr(
        fd: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_void,
        size: usize,
        position: u_int32_t,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn removexattr(
        path: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fremovexattr(
        fd: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listxattr(
        path: *const ::std::os::raw::c_char,
        namebuff: *mut ::std::os::raw::c_char,
        size: usize,
        options: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn flistxattr(
        fd: ::std::os::raw::c_int,
        namebuff: *mut ::std::os::raw::c_char,
        size: usize,
        options: ::std::os::raw::c_int,
    ) -> isize;
}
#[doc = " @brief es_file_t provides the stat information and path to a file that relates to a security\n event. The path may be truncated, which is indicated by the path_truncated flag.\n\n @field path Absolute path of the file\n @field path_truncated Indicates if the path field was truncated\n @field stat stat of file. See `man 2 stat` for details\n\n @note For the FAT family of filesystems the `stat.st_ino` field is set to 999999999 for empty files\n\n @discussion For files with a link count greater than 1, the absolute path given may not be the only absolute path that exists, and which hard link the emitted path points to is undefined.\n\n Overlong paths are truncated at a maximum length that currently is 16K, though that number is not considered API and may change at any time.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_file_t {
    pub path: es_string_token_t,
    pub path_truncated: bool,
    pub stat: stat,
}
#[test]
fn bindgen_test_layout_es_file_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_file_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_file_t>(),
        168usize,
        concat!("Size of: ", stringify!(es_file_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_file_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_file_t),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_truncated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_file_t),
            "::",
            stringify!(path_truncated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_file_t),
            "::",
            stringify!(stat)
        )
    );
}
#[doc = " @brief Information related to a thread.\n\n @field thread_id The unique thread ID of the thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_thread_t {
    pub thread_id: u64,
}
#[test]
fn bindgen_test_layout_es_thread_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_thread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_thread_t>(),
        8usize,
        concat!("Size of: ", stringify!(es_thread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_thread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_thread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_thread_t),
            "::",
            stringify!(thread_id)
        )
    );
}
#[doc = " @brief Information related to a process. This is used both for describing processes that\n performed an action (e.g. in the case of the `es_message_t` `process` field, or are targets\n of an action (e.g. for exec events this describes the new process being executed, for signal\n events this describes the process that will receive the signal).\n\n @field audit_token Audit token of the process.\n @field ppid Parent pid of the process. It is recommended to instead use the parent_audit_token field.\n        @see parent_audit_token\n @field original_ppid Original ppid of the process.  This field stays constant even in the event\n        this process is reparented.\n @field group_id Process group id the process belongs to.\n @field session_id Session id the process belongs to.\n @field codesigning_flags Code signing flags of the process.  The values for these flags can be\n        found in the include file `cs_blobs.h` (`#include <kern/cs_blobs.h>`).\n @field is_es_client Indicates this process has the Endpoint Security entitlement.\n @field cdhash The code directory hash of the code signature associated with this process.\n @field signing_id The signing id of the code signature associated with this process.\n @field team_id The team id of the code signature associated with this process.\n @field executable The executable file that is executing in this process.\n @field tty The TTY this process is associated with, or NULL if the process does not have an\n        associated TTY.  The TTY is a property of the POSIX session the process belongs to.\n        A process' session may be associated with a TTY independently from whether its stdin\n        or any other file descriptors point to a TTY device (as per isatty(3), tty(1)).\n        Field available only if message version >= 2.\n @field start_time Process start time, i.e. time of fork creating this process.\n        Field available only if message version >= 3.\n @field responsible_audit_token audit token of the process responsible for this process, which\n        may be the process itself in case there is no responsible process or the responsible\n        process has already exited.\n        Field available only if message version >= 4.\n @field parent_audit_token The audit token of the parent process\n        Field available only if message version >= 4.\n\n @discussion\n - Values such as pid, pidversion, uid, gid, etc. can be extracted from audit tokens using API\n   provided in libbsm.\n - The tuple (pid, pidversion) identifies a specific process execution, and should be used to link\n   events to the process that emitted them.  Executing an executable image in a process using the\n   exec or posix_spawn family of syscalls increments the pidversion.  However, (pid, pidversion)\n   is not meant to be unique across reboots or across multiple systems.\n - Clients should take caution when processing events where `is_es_client` is true. If multiple ES\n   clients exist, actions taken by one client could trigger additional actions by the other client,\n   causing a potentially infinite cycle.\n - Fields related to code signing in the target `es_process_t` reflect the state of the process\n   at the time the message is generated.  In the specific case of exec, this is after the exec\n   completed in the kernel, but before any code in the process has started executing.  At that\n   point, XNU has validated the signature itself and has verified that the CDHash is correct in\n   that the hash of all the individual page hashes in the Code Directory matches the signed CDHash,\n   essentially verifying the signature was not tampered with.  However, individual page hashes are\n   not verified by XNU until the corresponding pages are paged in once they are accessed while the\n   binary executes.  It is not until the individual pages are paged in that XNU determines if a\n   binary has been tampered with and will update the code signing flags accordingly.\n   EndpointSecurity provides clients the current state of the CS flags in the `codesigning_flags`\n   member of the `es_process_t` struct.  The CS_VALID bit in the `codesigning_flags` means that\n   everything the kernel has validated up to that point in time was valid, but not that there has\n   been a full validation of all the pages in the executable file.  If page content has been\n   tampered with in the executable, we won't know until that page is paged in.  At that time, the\n   process will have its CS_VALID bit cleared and, if CS_KILL is set, the process will be killed,\n   preventing any tampered code from being executed.  CS_KILL is generally set for platform\n   binaries and for binaries having opted into the hardened runtime.  An ES client wishing to\n   detect tampered code before it is paged in, for example at exec time, can use the Security\n   framework to do so, but should be cautious of the potentially significant performance cost.  The\n   EndpointSecurity subsystem itself has no role in verifying the validity of code signatures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_process_t {
    pub audit_token: audit_token_t,
    pub ppid: pid_t,
    pub original_ppid: pid_t,
    pub group_id: pid_t,
    pub session_id: pid_t,
    pub codesigning_flags: u32,
    pub is_platform_binary: bool,
    pub is_es_client: bool,
    pub cdhash: [u8; 20usize],
    pub signing_id: es_string_token_t,
    pub team_id: es_string_token_t,
    pub executable: *mut es_file_t,
    pub tty: *mut es_file_t,
    pub start_time: timeval,
    pub responsible_audit_token: audit_token_t,
    pub parent_audit_token: audit_token_t,
}
#[test]
fn bindgen_test_layout_es_process_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_process_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_process_t>(),
        208usize,
        concat!("Size of: ", stringify!(es_process_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_process_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_process_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audit_token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(audit_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(ppid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_ppid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(original_ppid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codesigning_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(codesigning_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_platform_binary) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(is_platform_binary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_es_client) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(is_es_client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdhash) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(cdhash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signing_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(signing_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).team_id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(team_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).executable) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(executable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tty) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_time) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).responsible_audit_token) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(responsible_audit_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_audit_token) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(es_process_t),
            "::",
            stringify!(parent_audit_token)
        )
    );
}
#[doc = " @brief Describes machine-specific thread state as used by `thread_create_running` and other\n Mach API functions.\n\n @field flavor Indicates the representation of the machine-specific thread state.\n @field state The machine-specific thread state, equivalent to thread_state_t in Mach APIs.\n\n @note The size subfield of the state field is in bytes, NOT natural_t units.  Definitions\n for working with thread state can be found in the include file `mach/thread_status.h` and\n corresponding machine-dependent headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_thread_state_t {
    pub flavor: ::std::os::raw::c_int,
    pub state: es_token_t,
}
#[test]
fn bindgen_test_layout_es_thread_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_thread_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_thread_state_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_thread_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_thread_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_thread_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flavor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_thread_state_t),
            "::",
            stringify!(flavor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_thread_state_t),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " @brief Structure for describing an open file descriptor\n\n @field fd File descriptor number\n @field fdtype File descriptor type, as libproc fdtype\n\n Fields available only if fdtype == PROX_FDTYPE_PIPE:\n @field extra.pipe.pipe_id Unique id of the pipe for correlation with other\n        file descriptors pointing to the same or other end of the same pipe."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_fd_t {
    pub fd: i32,
    pub fdtype: u32,
    pub __bindgen_anon_1: es_fd_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_fd_t__bindgen_ty_1 {
    pub pipe: es_fd_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_fd_t__bindgen_ty_1__bindgen_ty_1 {
    pub pipe_id: u64,
}
#[test]
fn bindgen_test_layout_es_fd_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_fd_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_fd_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(es_fd_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_fd_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_fd_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipe_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_fd_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pipe_id)
        )
    );
}
#[test]
fn bindgen_test_layout_es_fd_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_fd_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_fd_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(es_fd_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_fd_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(es_fd_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_fd_t__bindgen_ty_1),
            "::",
            stringify!(pipe)
        )
    );
}
#[test]
fn bindgen_test_layout_es_fd_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_fd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_fd_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_fd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_fd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_fd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_fd_t),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdtype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_fd_t),
            "::",
            stringify!(fdtype)
        )
    );
}
pub const es_btm_item_type_t_ES_BTM_ITEM_TYPE_USER_ITEM: es_btm_item_type_t = 0;
pub const es_btm_item_type_t_ES_BTM_ITEM_TYPE_APP: es_btm_item_type_t = 1;
pub const es_btm_item_type_t_ES_BTM_ITEM_TYPE_LOGIN_ITEM: es_btm_item_type_t = 2;
pub const es_btm_item_type_t_ES_BTM_ITEM_TYPE_AGENT: es_btm_item_type_t = 3;
pub const es_btm_item_type_t_ES_BTM_ITEM_TYPE_DAEMON: es_btm_item_type_t = 4;
pub type es_btm_item_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Structure describing a BTM launch item\n\n @field item_type             Type of launch item.\n @field legacy                True iff item is a legacy plist.\n @field managed               True iff item is managed by MDM.\n @field uid                   User ID for the item (may be user nobody (-2)).\n @field item_url              URL for item.\n                              If file URL describing a relative path, it is relative\n                              to app_url.\n @field app_url               Optional.  URL for app the item is attributed to."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_btm_launch_item_t {
    pub item_type: es_btm_item_type_t,
    pub legacy: bool,
    pub managed: bool,
    pub uid: uid_t,
    pub item_url: es_string_token_t,
    pub app_url: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_btm_launch_item_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_btm_launch_item_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_btm_launch_item_t>(),
        48usize,
        concat!("Size of: ", stringify!(es_btm_launch_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_btm_launch_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_btm_launch_item_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_btm_launch_item_t),
            "::",
            stringify!(item_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).legacy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_btm_launch_item_t),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managed) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(es_btm_launch_item_t),
            "::",
            stringify!(managed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_btm_launch_item_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item_url) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_btm_launch_item_t),
            "::",
            stringify!(item_url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_url) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_btm_launch_item_t),
            "::",
            stringify!(app_url)
        )
    );
}
pub const es_profile_source_t_ES_PROFILE_SOURCE_MANAGED: es_profile_source_t = 0;
pub const es_profile_source_t_ES_PROFILE_SOURCE_INSTALL: es_profile_source_t = 1;
pub type es_profile_source_t = ::std::os::raw::c_uint;
#[doc = " @brief Structure describing a Profile event\n\n @field identifier        Profile identifier.\n @field uuid                 Profile UUID.\n @field install_source    Source of Profile installation (MDM/Manual Install)\n @field organization        Profile organization name.\n @field display_name        Profile display name.\n @field scope                Profile scope."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_profile_t {
    pub identifier: es_string_token_t,
    pub uuid: es_string_token_t,
    pub install_source: es_profile_source_t,
    pub organization: es_string_token_t,
    pub display_name: es_string_token_t,
    pub scope: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_profile_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_profile_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_profile_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_profile_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_profile_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_profile_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_profile_t),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_profile_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).install_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_profile_t),
            "::",
            stringify!(install_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).organization) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_profile_t),
            "::",
            stringify!(organization)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_profile_t),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scope) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(es_profile_t),
            "::",
            stringify!(scope)
        )
    );
}
#[doc = " @brief Execute a new process\n\n @field target The new process that is being executed\n @field dyld_exec_path The exec path passed up to dyld, before symlink resolution.\n        This is the path argument to execve(2) or posix_spawn(2), or the interpreter\n        from the shebang line for scripts run through the shell script image activator.\n        Field available only if message version >= 7.\n @field script Script being executed by interpreter. This field is only valid if a script was\n        executed directly and not as an argument to the interpreter (e.g. `./foo.sh` not `/bin/sh ./foo.sh`)\n        Field available only if message version >= 2.\n @field cwd Current working directory at exec time.\n        Field available only if message version >= 3.\n @field last_fd Highest open file descriptor after the exec completed.\n        This number is equal to or larger than the highest number of file descriptors available\n        via `es_exec_fd_count` and `es_exec_fd`, in which case EndpointSecurity has capped the\n        number of file descriptors available in the message.  File descriptors for open files are\n        not necessarily contiguous.  The exact number of open file descriptors is not available.\n        Field available only if message version >= 4.\n @field image_cputype The CPU type of the executable image which is being executed.\n        In case of translation, this may be a different architecture than the one of the system.\n        Field available only if message version >= 6.\n @field image_cpusubtype The CPU subtype of the executable image.\n        Field available only if message version >= 6.\n\n @note Process arguments, environment variables and file descriptors are packed, use API functions\n to access them: `es_exec_arg`, `es_exec_arg_count`, `es_exec_env`, `es_exec_env_count`,\n `es_exec_fd` and `es_exec_fd_count`.\n\n @note The API may only return descriptions for a subset of open file descriptors; how many and\n which file descriptors are available as part of exec events is not considered API and can change\n in future releases.\n\n @note The CPU type and subtype correspond to CPU_TYPE_* and CPU_SUBTYPE_* macros defined in\n `<mach/machine.h>`.\n\n @note Fields related to code signing in `target` represent kernel state for the process at the\n point in time the exec has completed, but the binary has not started running yet.  Because code\n pages are not validated until they are paged in, this means that modifications to code pages\n would not have been detected yet at this point.  For a more thorough explanation, please see the\n documentation for `es_process_t`.\n\n @note There are two `es_process_t` fields that are represented in an `es_message_t` that contains\n an `es_event_exec_t`. The `es_process_t` within the `es_message_t` struct (named \"process\")\n contains information about the program that calls execve(2) (or posix_spawn(2)). This information\n is gathered prior to the program being replaced. The other `es_process_t`, within the\n `es_event_exec_t` struct (named \"target\"), contains information about the program after the image\n has been replaced by execve(2) (or posix_spawn(2)). This means that both `es_process_t` structs\n refer to the same process (as identified by pid), but not necessarily the same program, and\n definitely not the same program execution (as identified by pid, pidversion tuple). The\n `audit_token_t` structs contained in the two different `es_process_t` structs will not be\n identical: the pidversion field will be updated, and the uid/gid values may be different if the\n new program had setuid/setgid permission bits set.\n\n @note Cache key for this event type:  (process executable file, target executable file)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_exec_t {
    pub target: *mut es_process_t,
    pub dyld_exec_path: es_string_token_t,
    pub __bindgen_anon_1: es_event_exec_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_exec_t__bindgen_ty_1 {
    pub reserved: [u8; 64usize],
    pub __bindgen_anon_1: es_event_exec_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_exec_t__bindgen_ty_1__bindgen_ty_1 {
    pub script: *mut es_file_t,
    pub cwd: *mut es_file_t,
    pub last_fd: ::std::os::raw::c_int,
    pub image_cputype: cpu_type_t,
    pub image_cpusubtype: cpu_subtype_t,
}
#[test]
fn bindgen_test_layout_es_event_exec_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_exec_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_exec_t__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_exec_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).script) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_cputype) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(image_cputype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_cpusubtype) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(image_cpusubtype)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_exec_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_exec_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_exec_t__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_exec_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_exec_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_exec_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_exec_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_exec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_exec_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_exec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_exec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_exec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dyld_exec_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exec_t),
            "::",
            stringify!(dyld_exec_path)
        )
    );
}
#[doc = " @brief Open a file system object\n\n @field fflag The desired flags to be used when opening `file` (see note)\n @field file The file that will be opened\n\n @note: The `fflag` field represents the mask as applied by the kernel, not as represented by typical\n open(2) `oflag` values. When responding to `ES_EVENT_TYPE_AUTH_OPEN` events using\n es_respond_flags_result(), ensure that the same FFLAG values are used (e.g. FREAD, FWRITE instead\n of O_RDONLY, O_RDWR, etc...).\n\n @note Cache key for this event type:  (process executable file, file that will be opened)\n\n @see fcntl.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_open_t {
    pub fflag: i32,
    pub file: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_open_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_open_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_open_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_open_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_open_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_open_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fflag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_open_t),
            "::",
            stringify!(fflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_open_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_open_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Load a kernel extension\n\n @field identifier The signing identifier of the kext being loaded\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_kextload_t {
    pub identifier: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_kextload_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_kextload_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_kextload_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_kextload_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_kextload_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_kextload_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_kextload_t),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_kextload_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Unload a kernel extension\n\n @field identifier The signing identifier of the kext being unloaded\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_kextunload_t {
    pub identifier: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_kextunload_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_kextunload_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_kextunload_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_kextunload_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_kextunload_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_kextunload_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_kextunload_t),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_kextunload_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Unlink a file system object\n\n @field target The object that will be removed\n @field parent_dir The parent directory of the `target` file system object\n\n @note This event can fire multiple times for a single syscall, for example when the syscall\n       has to be retried due to racing VFS operations.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_unlink_t {
    pub target: *mut es_file_t,
    pub parent_dir: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_unlink_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_unlink_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_unlink_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_unlink_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_unlink_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_unlink_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_unlink_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_dir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_unlink_t),
            "::",
            stringify!(parent_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_unlink_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Memory map a file\n\n @field protection The protection (region accessibility) value\n @field max_protection The maximum allowed protection value the operating system will respect\n @field flags The type and attributes of the mapped file\n @field file_pos The offset into `source` that will be mapped\n @field source The file system object being mapped\n\n @note Cache key for this event type:  (process executable file, source file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_mmap_t {
    pub protection: i32,
    pub max_protection: i32,
    pub flags: i32,
    pub file_pos: u64,
    pub source: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_mmap_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_mmap_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_mmap_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_mmap_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_mmap_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_mmap_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mmap_t),
            "::",
            stringify!(protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_protection) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mmap_t),
            "::",
            stringify!(max_protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mmap_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_pos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mmap_t),
            "::",
            stringify!(file_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mmap_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mmap_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Link to a file\n\n @field source The existing object to which a hard link will be created\n @field target_dir The directory in which the link will be created\n @field target_filename The name of the new object linked to `source`\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_link_t {
    pub source: *mut es_file_t,
    pub target_dir: *mut es_file_t,
    pub target_filename: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_link_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_link_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_link_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_link_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_link_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_link_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_link_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_dir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_link_t),
            "::",
            stringify!(target_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_link_t),
            "::",
            stringify!(target_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_link_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Mount a file system\n\n @field statfs The file system stats for the file system being mounted\n\n @note Cache key for this event type:  (process executable file, mount point)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_mount_t {
    pub statfs: *mut statfs,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_mount_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_mount_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_mount_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_mount_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_mount_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_mount_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statfs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mount_t),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mount_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Unmount a file system\n\n @field statfs The file system stats for the file system being unmounted\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_unmount_t {
    pub statfs: *mut statfs,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_unmount_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_unmount_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_unmount_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_unmount_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_unmount_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_unmount_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statfs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_unmount_t),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_unmount_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Remount a file system\n\n @field statfs The file system stats for the file system being remounted\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_remount_t {
    pub statfs: *mut statfs,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_remount_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_remount_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_remount_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_remount_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_remount_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_remount_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statfs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_remount_t),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_remount_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Fork a new process\n\n @field child The child process that was created\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_fork_t {
    pub child: *mut es_process_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_fork_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_fork_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_fork_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_fork_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_fork_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_fork_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fork_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fork_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Control protection of pages\n\n @field protection The desired new protection value\n @field address The base address to which the protection value will apply\n @field size The size of the memory region the protection value will apply\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_mprotect_t {
    pub protection: i32,
    pub address: user_addr_t,
    pub size: user_size_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_mprotect_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_mprotect_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_mprotect_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_mprotect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_mprotect_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_mprotect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mprotect_t),
            "::",
            stringify!(protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mprotect_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mprotect_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_mprotect_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Send a signal to a process\n\n @field sig The signal number to be delivered\n @field target The process that will receive the signal\n\n @note This event will not fire if a process sends a signal to itself.\n\n @note Cache key for this event type:  (process executable file, target process executable file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_signal_t {
    pub sig: ::std::os::raw::c_int,
    pub target: *mut es_process_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_signal_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_signal_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_signal_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_signal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_signal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_signal_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_signal_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_signal_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_signal_t),
            "::",
            stringify!(reserved)
        )
    );
}
pub const es_destination_type_t_ES_DESTINATION_TYPE_EXISTING_FILE: es_destination_type_t = 0;
pub const es_destination_type_t_ES_DESTINATION_TYPE_NEW_PATH: es_destination_type_t = 1;
pub type es_destination_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Rename a file system object\n\n @field source The source file that is being renamed\n @field destination_type Whether or not the destination refers to an existing or new file\n @field destination Information about the destination of the renamed file (see note)\n @field existing_file The destination file that will be overwritten\n @field new_path Information regarding the destination of a newly created file\n @field dir The directory into which the file will be renamed\n @field filename The name of the new file that will be created\n\n @note The `destination_type` field describes which member in the `destination` union should\n accessed. `ES_DESTINATION_TYPE_EXISTING_FILE` means that `existing_file` should be used,\n `ES_DESTINATION_TYPE_NEW_PATH` means that the `new_path` struct should be used.\n\n @note This event can fire multiple times for a single syscall, for example when the syscall\n       has to be retried due to racing VFS operations.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_rename_t {
    pub source: *mut es_file_t,
    pub destination_type: es_destination_type_t,
    pub destination: es_event_rename_t__bindgen_ty_1,
    pub reserved: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_rename_t__bindgen_ty_1 {
    pub existing_file: *mut es_file_t,
    pub new_path: es_event_rename_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_rename_t__bindgen_ty_1__bindgen_ty_1 {
    pub dir: *mut es_file_t,
    pub filename: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_rename_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_rename_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_rename_t__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(es_event_rename_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_rename_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_rename_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(filename)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_rename_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_rename_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_rename_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_rename_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_rename_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_rename_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).existing_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t__bindgen_ty_1),
            "::",
            stringify!(existing_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t__bindgen_ty_1),
            "::",
            stringify!(new_path)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_rename_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_rename_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_rename_t>(),
        104usize,
        concat!("Size of: ", stringify!(es_event_rename_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_rename_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_rename_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t),
            "::",
            stringify!(destination_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_rename_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Set an extended attribute\n\n @field target The file for which the extended attribute will be set\n @field extattr The extended attribute which will be set\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setextattr_t {
    pub target: *mut es_file_t,
    pub extattr: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setextattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setextattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setextattr_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_setextattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setextattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setextattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setextattr_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extattr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setextattr_t),
            "::",
            stringify!(extattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setextattr_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Retrieve an extended attribute\n\n @field target The file for which the extended attribute will be retrieved\n @field extattr The extended attribute which will be retrieved\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_getextattr_t {
    pub target: *mut es_file_t,
    pub extattr: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_getextattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_getextattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_getextattr_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_getextattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_getextattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_getextattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_getextattr_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extattr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_getextattr_t),
            "::",
            stringify!(extattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_getextattr_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Delete an extended attribute\n\n @field target The file for which the extended attribute will be deleted\n @field extattr The extended attribute which will be deleted\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_deleteextattr_t {
    pub target: *mut es_file_t,
    pub extattr: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_deleteextattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_deleteextattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_deleteextattr_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_deleteextattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_deleteextattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_deleteextattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_deleteextattr_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extattr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_deleteextattr_t),
            "::",
            stringify!(extattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_deleteextattr_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Modify file mode\n\n @field mode The desired new mode\n @field target The file for which mode information will be modified\n\n @note The `mode` member is the desired new mode. The `target`\n member's `stat` information contains the current mode.\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setmode_t {
    pub mode: mode_t,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setmode_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setmode_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setmode_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_setmode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setmode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setmode_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setmode_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setmode_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setmode_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Modify file flags information\n\n @field flags The desired new flags\n @field target The file for which flags information will be modified\n\n @note The `flags` member is the desired set of new flags. The `target`\n member's `stat` information contains the current set of flags.\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setflags_t {
    pub flags: u32,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setflags_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setflags_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setflags_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_setflags_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setflags_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setflags_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setflags_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setflags_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setflags_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Modify file owner information\n\n @field uid The desired new UID\n @field gid The desired new GID\n @field target The file for which owner information will be modified\n\n @note The `uid` and `gid` members are the desired new values. The `target`\n member's `stat` information contains the current uid and gid values.\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setowner_t {
    pub uid: uid_t,
    pub gid: gid_t,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setowner_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setowner_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setowner_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_setowner_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setowner_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setowner_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setowner_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setowner_t),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setowner_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setowner_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Close a file descriptor\n\n @field modified Set to TRUE if the target file being closed has been modified\n @field target The file that is being closed\n @field was_mapped_writable Indicates that at some point in the lifetime of the\n        target file vnode it was mapped into a process as writable.\n        Field available only if message version >= 6.\n\n @note This event type does not support caching (notify-only).\n\n `was_mapped_writable` only indicates whether the target file was mapped into writable memory or not for the lifetime of the vnode.\n It does not indicate whether the file has actually been written to by way of writing to mapped memory, and it does not indicate whether the file is currently still mapped writable.\n Correct interpretation requires consideration of vnode lifetimes in the kernel.\n\n The `modified` flag only reflects that a file was or was not modified by filesystem syscall.\n If a file was only modifed though a memory mapping this flag will be false, but was_mapped_writable will be true."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_close_t {
    pub modified: bool,
    pub target: *mut es_file_t,
    pub __bindgen_anon_1: es_event_close_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_close_t__bindgen_ty_1 {
    pub reserved: [u8; 64usize],
    pub __bindgen_anon_1: es_event_close_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_close_t__bindgen_ty_1__bindgen_ty_1 {
    pub was_mapped_writable: bool,
}
#[test]
fn bindgen_test_layout_es_event_close_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_close_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_close_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(es_event_close_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_close_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_close_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).was_mapped_writable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_close_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(was_mapped_writable)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_close_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_close_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_close_t__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_close_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_close_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(es_event_close_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_close_t__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_close_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_close_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_close_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_close_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_close_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_close_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_close_t),
            "::",
            stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_close_t),
            "::",
            stringify!(target)
        )
    );
}
#[doc = " @brief Create a file system object\n\n @field destination_type Whether or not the destination refers to an existing file (see note)\n @field destination Information about the destination of the new file (see note)\n @field existing_file The file system object that was created\n @field dir The directory in which the new file system object will be created\n @field filename The name of the new file system object to create\n @field acl The ACL that the new file system object got or gets created with.\n        May be NULL if the file system object gets created without ACL.\n        @note The acl provided cannot be directly used by functions within\n        the <sys/acl.h> header. These functions can mutate the struct passed\n        into them, which is not compatible with the immutable nature of\n        es_message_t. Additionally, because this field is minimally constructed,\n        you must not use `acl_dup(3)` to get a mutable copy, as this can lead to\n        out of bounds memory access. To obtain a acl_t struct that is able to be\n        used with all functions within <sys/acl.h>, please use a combination of\n        `acl_copy_ext(3)` followed by `acl_copy_int(3)`.\n        Field available only if message version >= 2.\n\n @note If an object is being created but has not yet been created, the\n `destination_type` will be `ES_DESTINATION_TYPE_NEW_PATH`.\n\n @note Typically `ES_EVENT_TYPE_NOTIFY_CREATE` events are fired after the\n object has been created and the `destination_type` will be\n `ES_DESTINATION_TYPE_EXISTING_FILE`. The exception to this is for\n notifications that occur if an ES client responds to an\n `ES_EVENT_TYPE_AUTH_CREATE` event with `ES_AUTH_RESULT_DENY`.\n\n @note This event can fire multiple times for a single syscall, for example when the syscall\n       has to be retried due to racing VFS operations.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_create_t {
    pub destination_type: es_destination_type_t,
    pub destination: es_event_create_t__bindgen_ty_1,
    pub reserved2: [u8; 16usize],
    pub __bindgen_anon_1: es_event_create_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_create_t__bindgen_ty_1 {
    pub existing_file: *mut es_file_t,
    pub new_path: es_event_create_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_create_t__bindgen_ty_1__bindgen_ty_1 {
    pub dir: *mut es_file_t,
    pub filename: es_string_token_t,
    pub mode: mode_t,
}
#[test]
fn bindgen_test_layout_es_event_create_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_create_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_create_t__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(es_event_create_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_create_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_create_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mode)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_create_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_create_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_create_t__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(es_event_create_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_create_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_create_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).existing_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_1),
            "::",
            stringify!(existing_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_1),
            "::",
            stringify!(new_path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_create_t__bindgen_ty_2 {
    pub reserved: [u8; 48usize],
    pub __bindgen_anon_1: es_event_create_t__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_create_t__bindgen_ty_2__bindgen_ty_1 {
    pub acl: acl_t,
}
#[test]
fn bindgen_test_layout_es_event_create_t__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_create_t__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_create_t__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(es_event_create_t__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_create_t__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_create_t__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(acl)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_create_t__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_create_t__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_create_t__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(es_event_create_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_create_t__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_create_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_create_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_create_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_create_t>(),
        104usize,
        concat!("Size of: ", stringify!(es_event_create_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_create_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_create_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t),
            "::",
            stringify!(destination_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_create_t),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " @brief Terminate a process\n\n @field stat The exit status of a process (same format as wait(2))\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_exit_t {
    pub stat: ::std::os::raw::c_int,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_exit_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_exit_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_exit_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_exit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_exit_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_exit_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exit_t),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exit_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Exchange data atomically between two files\n\n @field file1 The first file to be exchanged\n @field file2 The second file to be exchanged\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_exchangedata_t {
    pub file1: *mut es_file_t,
    pub file2: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_exchangedata_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_exchangedata_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_exchangedata_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_exchangedata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_exchangedata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_exchangedata_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exchangedata_t),
            "::",
            stringify!(file1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exchangedata_t),
            "::",
            stringify!(file2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_exchangedata_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Write to a file\n\n @field target The file being written to\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_write_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_write_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_write_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_write_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_write_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_write_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_write_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_write_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_write_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Truncate a file\n\n @field target The file that is being truncated\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_truncate_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_truncate_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_truncate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_truncate_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_truncate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_truncate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_truncate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_truncate_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_truncate_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Change directories\n\n @field target The desired new current working directory\n\n @note Cache key for this event type:  (process executable file, target directory)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_chdir_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_chdir_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_chdir_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_chdir_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_chdir_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_chdir_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_chdir_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_chdir_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_chdir_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief View stat information of a file\n\n @field target The file for which stat information will be retrieved\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_stat_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_stat_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_stat_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_stat_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_stat_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_stat_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_stat_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Change the root directory for a process\n\n @field target The directory which will be the new root\n\n @note Cache key for this event type:  (process executable file, target directory)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_chroot_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_chroot_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_chroot_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_chroot_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_chroot_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_chroot_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_chroot_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_chroot_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_chroot_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief List extended attributes of a file\n\n @field target The file for which extended attributes are being retrieved\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_listextattr_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_listextattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_listextattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_listextattr_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_listextattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_listextattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_listextattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_listextattr_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_listextattr_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Open a connection to an I/O Kit IOService\n\n @field user_client_type A constant specifying the type of connection to be\n        created, interpreted only by the IOService's family.\n        This field corresponds to the type argument to IOServiceOpen().\n @field user_client_class Meta class name of the user client instance.\n\n This event is fired when a process calls IOServiceOpen() in order to open\n a communications channel with an I/O Kit driver.  The event does not\n correspond to driver <-> device communication and is neither providing\n visibility nor access control into devices being attached.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_iokit_open_t {
    pub user_client_type: u32,
    pub user_client_class: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_iokit_open_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_iokit_open_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_iokit_open_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_iokit_open_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_iokit_open_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_iokit_open_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_client_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_iokit_open_t),
            "::",
            stringify!(user_client_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_client_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_iokit_open_t),
            "::",
            stringify!(user_client_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_iokit_open_t),
            "::",
            stringify!(reserved)
        )
    );
}
pub const es_get_task_type_t_ES_GET_TASK_TYPE_TASK_FOR_PID: es_get_task_type_t = 0;
pub const es_get_task_type_t_ES_GET_TASK_TYPE_EXPOSE_TASK: es_get_task_type_t = 1;
pub const es_get_task_type_t_ES_GET_TASK_TYPE_IDENTITY_TOKEN: es_get_task_type_t = 2;
pub type es_get_task_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Get a process's task control port\n\n @field target The process for which the task control port will be retrieved.\n @field type Type indicating how the process is obtaining the task port for\n        the target process.\n        Field available only if message version >= 5.\n\n This event is fired when a process obtains a send right to a task control\n port (e.g. task_for_pid(), task_identity_token_get_task_port(),\n processor_set_tasks() and other means).\n\n @note Task control ports were formerly known as simply \"task ports\".\n\n @note There are many legitimate reasons why a process might need to obtain\n a send right to a task control port of another process, not limited to intending\n to debug or suspend the target process.  For instance, frameworks and their\n daemons may need to obtain a task control port to fulfill requests made by the\n target process.  Obtaining a task control port is in itself not indicative of\n malicious activity.  Denying system processes acquiring task control ports may\n result in breaking system functionality in potentially fatal ways.\n\n @note Cache key for this event type:\n (process executable file, target executable file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_get_task_t {
    pub target: *mut es_process_t,
    pub type_: es_get_task_type_t,
    pub reserved: [u8; 60usize],
}
#[test]
fn bindgen_test_layout_es_event_get_task_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_get_task_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_get_task_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_get_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_get_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_get_task_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Get a process's task read port\n\n @field target The process for which the task read port will be retrieved.\n @field type Type indicating how the process is obtaining the task port for\n        the target process.\n        Field available only if message version >= 5.\n\n This event is fired when a process obtains a send right to a task read\n port (e.g. task_read_for_pid(), task_identity_token_get_task_port()).\n\n @note Cache key for this event type:\n (process executable file, target executable file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_get_task_read_t {
    pub target: *mut es_process_t,
    pub type_: es_get_task_type_t,
    pub reserved: [u8; 60usize],
}
#[test]
fn bindgen_test_layout_es_event_get_task_read_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_get_task_read_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_get_task_read_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_get_task_read_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_get_task_read_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_get_task_read_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_read_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_read_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_read_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Get a process's task inspect port\n\n @field target The process for which the task inspect port will be retrieved.\n @field type Type indicating how the process is obtaining the task port for\n        the target process.\n        Field available only if message version >= 5.\n\n This event is fired when a process obtains a send right to a task inspect\n port (e.g. task_inspect_for_pid(), task_identity_token_get_task_port()).\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_get_task_inspect_t {
    pub target: *mut es_process_t,
    pub type_: es_get_task_type_t,
    pub reserved: [u8; 60usize],
}
#[test]
fn bindgen_test_layout_es_event_get_task_inspect_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_get_task_inspect_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_get_task_inspect_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_get_task_inspect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_get_task_inspect_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_get_task_inspect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_inspect_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_inspect_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_inspect_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Get a process's task name port\n\n @field target The process for which the task name port will be retrieved.\n @field type Type indicating how the process is obtaining the task port for\n        the target process.\n        Field available only if message version >= 5.\n\n This event is fired when a process obtains a send right to a task name\n port (e.g. task_name_for_pid(), task_identity_token_get_task_port()).\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_get_task_name_t {
    pub target: *mut es_process_t,
    pub type_: es_get_task_type_t,
    pub reserved: [u8; 60usize],
}
#[test]
fn bindgen_test_layout_es_event_get_task_name_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_get_task_name_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_get_task_name_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_get_task_name_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_get_task_name_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_get_task_name_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_name_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_name_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_get_task_name_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Retrieve file system attributes\n\n @field attrlist The attributes that will be retrieved\n @field target The file for which attributes will be retrieved\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_getattrlist_t {
    pub attrlist: attrlist,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_getattrlist_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_getattrlist_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_getattrlist_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_getattrlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_getattrlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_getattrlist_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_getattrlist_t),
            "::",
            stringify!(attrlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_getattrlist_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_getattrlist_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Set file system attributes\n\n @field attrlist The attributes that will be modified\n @field target The file for which attributes will be modified\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setattrlist_t {
    pub attrlist: attrlist,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setattrlist_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setattrlist_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setattrlist_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_setattrlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setattrlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setattrlist_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setattrlist_t),
            "::",
            stringify!(attrlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setattrlist_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setattrlist_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Update file contents via the FileProvider framework\n\n @field source The staged file that has had its contents updated\n @field target_path The destination that the staged `source` file will be moved to\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_file_provider_update_t {
    pub source: *mut es_file_t,
    pub target_path: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_file_provider_update_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_file_provider_update_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_file_provider_update_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_file_provider_update_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_file_provider_update_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_file_provider_update_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_update_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_update_t),
            "::",
            stringify!(target_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_update_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Materialize a file via the FileProvider framework\n\n @field source The staged file that has been materialized\n @field target The destination of the staged `source` file\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_file_provider_materialize_t {
    pub instigator: *mut es_process_t,
    pub source: *mut es_file_t,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_file_provider_materialize_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_file_provider_materialize_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_file_provider_materialize_t>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(es_event_file_provider_materialize_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_file_provider_materialize_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_file_provider_materialize_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_materialize_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_materialize_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_materialize_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_file_provider_materialize_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Resolve a symbolic link\n\n @field source The symbolic link that is attempting to be resolved\n\n @note This is not limited only to readlink(2). Other operations such as path lookups\n can also cause this event to be fired."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_readlink_t {
    pub source: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_readlink_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_readlink_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_readlink_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_readlink_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_readlink_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_readlink_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_readlink_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_readlink_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Lookup a file system object\n\n @field source_dir The current directory\n @field relative_target The path to lookup relative to the `source_dir`\n\n @note The `relative_target` data may contain untrusted user input.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_lookup_t {
    pub source_dir: *mut es_file_t,
    pub relative_target: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_lookup_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_lookup_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_lookup_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_lookup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_lookup_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_lookup_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lookup_t),
            "::",
            stringify!(source_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relative_target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lookup_t),
            "::",
            stringify!(relative_target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lookup_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Test file access\n\n @field mode Access permission to check\n @field target The file to check for access\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_access_t {
    pub mode: i32,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_access_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_access_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_access_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_access_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_access_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_access_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_access_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_access_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_access_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Change file access and modification times (e.g. via utimes(2))\n\n @field target The path which will have its times modified\n @field atime The desired new access time\n @field mtime The desired new modification time\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_utimes_t {
    pub target: *mut es_file_t,
    pub atime: timespec,
    pub mtime: timespec,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_utimes_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_utimes_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_utimes_t>(),
        104usize,
        concat!("Size of: ", stringify!(es_event_utimes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_utimes_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_utimes_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_utimes_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_utimes_t),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_utimes_t),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_utimes_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Clone a file\n\n @field source The file that will be cloned\n @field target_dir The directory into which the `source` file will be cloned\n @field target_name The name of the new file to which `source` will be cloned\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_clone_t {
    pub source: *mut es_file_t,
    pub target_dir: *mut es_file_t,
    pub target_name: es_string_token_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_clone_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_clone_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_clone_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_clone_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_clone_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_clone_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_clone_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_dir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_clone_t),
            "::",
            stringify!(target_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_clone_t),
            "::",
            stringify!(target_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_clone_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Copy a file using the copyfile syscall\n\n @field source The file that will be cloned\n @field target_file The file existing at the target path that will be overwritten\n                    by the copyfile operation.  NULL if no such file exists.\n @field target_dir The directory into which the `source` file will be copied\n @field target_name The name of the new file to which `source` will be copied\n @field mode Corresponds to mode argument of the copyfile syscall\n @field flags Corresponds to flags argument of the copyfile syscall\n\n @note Not to be confused with copyfile(3).\n @note Prior to macOS 12.0, the copyfile syscall fired open, unlink and auth\n       create events, but no notify create, nor write or close events.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_copyfile_t {
    pub source: *mut es_file_t,
    pub target_file: *mut es_file_t,
    pub target_dir: *mut es_file_t,
    pub target_name: es_string_token_t,
    pub mode: mode_t,
    pub flags: i32,
    pub reserved: [u8; 56usize],
}
#[test]
fn bindgen_test_layout_es_event_copyfile_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_copyfile_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_copyfile_t>(),
        104usize,
        concat!("Size of: ", stringify!(es_event_copyfile_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_copyfile_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_copyfile_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(target_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_dir) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(target_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(target_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_copyfile_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief File control\n\n @field target The target file on which the file control command will be performed\n @field cmd The `cmd` argument given to fcntl(2)\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_fcntl_t {
    pub target: *mut es_file_t,
    pub cmd: i32,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_fcntl_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_fcntl_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_fcntl_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_fcntl_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_fcntl_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_fcntl_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fcntl_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fcntl_t),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fcntl_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Read directory entries\n\n @field target The directory whose contents will be read\n\n @note Cache key for this event type:  (process executable file, target directory)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_readdir_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_readdir_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_readdir_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_readdir_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_readdir_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_readdir_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_readdir_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_readdir_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_readdir_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Retrieve file system path based on FSID\n\n @field target Describes the file system path that will be retrieved\n\n @note This event can fire multiple times for a single syscall, for example when the syscall\n       has to be retried due to racing VFS operations.\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_fsgetpath_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_fsgetpath_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_fsgetpath_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_fsgetpath_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_fsgetpath_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_fsgetpath_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_fsgetpath_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fsgetpath_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_fsgetpath_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Modify the system time\n\n @note This event is not fired if the program contains the entitlement\n com.apple.private.settime. Additionally, even if an ES client responds to\n ES_EVENT_TYPE_AUTH_SETTIME events with ES_AUTH_RESULT_ALLOW, the operation\n may still fail for other reasons (e.g. unprivileged user).\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_settime_t {
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_settime_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_settime_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_settime_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_settime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_settime_t>(),
        1usize,
        concat!("Alignment of ", stringify!(es_event_settime_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_settime_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Duplicate a file descriptor\n\n @field target Describes the file the duplicated file descriptor points to\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_dup_t {
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_dup_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_dup_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_dup_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_dup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_dup_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_dup_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_dup_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_dup_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Fired when a UNIX-domain socket is about to be bound to a path.\n\n @field dir Describes the directory the socket file is created in.\n @field filename The filename of the socket file.\n @field mode The mode of the socket file.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_uipc_bind_t {
    pub dir: *mut es_file_t,
    pub filename: es_string_token_t,
    pub mode: mode_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_uipc_bind_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_uipc_bind_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_uipc_bind_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_uipc_bind_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_uipc_bind_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_uipc_bind_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_bind_t),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_bind_t),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_bind_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_bind_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Fired when a UNIX-domain socket is about to be connected.\n\n @field file Describes the socket file that the socket is bound to.\n @field domain The communications domain of the socket (see socket(2)).\n @field type The type of the socket (see socket(2)).\n @field protocol The protocol of the socket (see socket(2)).\n\n @note Cache key for this event type:  (process executable file, socket file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_uipc_connect_t {
    pub file: *mut es_file_t,
    pub domain: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub protocol: ::std::os::raw::c_int,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_uipc_connect_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_uipc_connect_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_uipc_connect_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_uipc_connect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_uipc_connect_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_uipc_connect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_connect_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_connect_t),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_connect_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_connect_t),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_uipc_connect_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Set a file ACL.\n\n @field set_or_clear Describes whether or not the ACL on the `target` is being set or cleared\n @field acl Union that is valid when `set_or_clear` is set to `ES_SET`\n @field set The acl_t structure to be used by various acl(3) functions\n        @note The acl provided cannot be directly used by functions within\n        the <sys/acl.h> header. These functions can mutate the struct passed\n        into them, which is not compatible with the immutable nature of\n        es_message_t. Additionally, because this field is minimally constructed,\n        you must not use `acl_dup(3)` to get a mutable copy, as this can lead to\n        out of bounds memory access. To obtain a acl_t struct that is able to be\n        used with all functions within <sys/acl.h>, please use a combination of\n        `acl_copy_ext(3)` followed by `acl_copy_int(3)`.\n @field target Describes the file whose ACL is being set.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_setacl_t {
    pub target: *mut es_file_t,
    pub set_or_clear: es_set_or_clear_t,
    pub acl: es_event_setacl_t__bindgen_ty_1,
    pub reserved: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_setacl_t__bindgen_ty_1 {
    pub set: acl_t,
}
#[test]
fn bindgen_test_layout_es_event_setacl_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setacl_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setacl_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(es_event_setacl_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setacl_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setacl_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setacl_t__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_setacl_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setacl_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setacl_t>(),
        88usize,
        concat!("Size of: ", stringify!(es_event_setacl_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setacl_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_setacl_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setacl_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_or_clear) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setacl_t),
            "::",
            stringify!(set_or_clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setacl_t),
            "::",
            stringify!(acl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setacl_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Fired when a pseudoterminal control device is granted\n\n @field dev Major and minor numbers of device\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_pty_grant_t {
    pub dev: dev_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_pty_grant_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_pty_grant_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_pty_grant_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_pty_grant_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_pty_grant_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_pty_grant_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_pty_grant_t),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_pty_grant_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Fired when a pseudoterminal control device is closed\n\n @field dev Major and minor numbers of device\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_pty_close_t {
    pub dev: dev_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_pty_close_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_pty_close_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_pty_close_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_pty_close_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_pty_close_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_pty_close_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_pty_close_t),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_pty_close_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Access control check for retrieving process information.\n\n @field target The process for which the access will be checked\n @field type The type of call number used to check the access on the target process\n @field flavor The flavor used to check the access on the target process\n\n @note Cache key for this event type:  (process executable file, target process executable file, type)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_proc_check_t {
    pub target: *mut es_process_t,
    pub type_: es_proc_check_type_t,
    pub flavor: ::std::os::raw::c_int,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_proc_check_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_proc_check_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_proc_check_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_proc_check_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_proc_check_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_proc_check_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_check_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_check_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flavor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_check_t),
            "::",
            stringify!(flavor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_check_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Access control check for searching a volume or a mounted file system\n\n @field attrlist The attributes that will be used to do the search\n @field target The volume whose contents will be searched\n\n @note Cache key for this event type:  (process executable file, target file)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_searchfs_t {
    pub attrlist: attrlist,
    pub target: *mut es_file_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_searchfs_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_searchfs_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_searchfs_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_searchfs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_searchfs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_searchfs_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_searchfs_t),
            "::",
            stringify!(attrlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_searchfs_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_searchfs_t),
            "::",
            stringify!(reserved)
        )
    );
}
pub const es_proc_suspend_resume_type_t_ES_PROC_SUSPEND_RESUME_TYPE_SUSPEND:
    es_proc_suspend_resume_type_t = 0;
pub const es_proc_suspend_resume_type_t_ES_PROC_SUSPEND_RESUME_TYPE_RESUME:
    es_proc_suspend_resume_type_t = 1;
pub const es_proc_suspend_resume_type_t_ES_PROC_SUSPEND_RESUME_TYPE_SHUTDOWN_SOCKETS:
    es_proc_suspend_resume_type_t = 3;
#[doc = " @brief This enum describes the type of suspend/resume operations that are currently used."]
pub type es_proc_suspend_resume_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Fired when one of pid_suspend, pid_resume or pid_shutdown_sockets\n is called on a process.\n\n @field target The process that is being suspended, resumed, or is the object\n of a pid_shutdown_sockets call.\n @field type The type of operation that was called on the target process.\n\n @note This event type does not support caching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_proc_suspend_resume_t {
    pub target: *mut es_process_t,
    pub type_: es_proc_suspend_resume_type_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_proc_suspend_resume_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_proc_suspend_resume_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_proc_suspend_resume_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_proc_suspend_resume_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_proc_suspend_resume_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_proc_suspend_resume_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_suspend_resume_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_suspend_resume_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_proc_suspend_resume_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Code signing status for process was invalidated.\n\n @note This event fires when the CS_VALID bit is removed from a\n process' CS flags, that is, when the first invalid page is paged in\n for a process with an otherwise valid code signature, or when a\n process is explicitly invalidated by a csops(CS_OPS_MARKINVALID)\n syscall.  This event does not fire if CS_HARD was set, since CS_HARD\n by design prevents the process from going invalid.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_cs_invalidated_t {
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_cs_invalidated_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_cs_invalidated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_cs_invalidated_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_cs_invalidated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_cs_invalidated_t>(),
        1usize,
        concat!("Alignment of ", stringify!(es_event_cs_invalidated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_cs_invalidated_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Fired when one process attempts to attach to another process\n\n @field target The process that will be attached to by the process\n that instigated the event\n\n @note This event can fire multiple times for a single trace attempt, for example\n when the processes to which is being attached is reparented during the operation\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_trace_t {
    pub target: *mut es_process_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_trace_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_trace_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_trace_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_trace_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_trace_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_trace_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_trace_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_trace_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has attempted to create a thread in\n another process by calling one of the thread_create or thread_create_running\n MIG routines.\n\n @field target The process in which a new thread was created\n @field thread_state The new thread state in case of thread_create_running,\n NULL in case of thread_create.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_remote_thread_create_t {
    pub target: *mut es_process_t,
    pub thread_state: *mut es_thread_state_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_remote_thread_create_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_remote_thread_create_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_remote_thread_create_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_remote_thread_create_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_remote_thread_create_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_remote_thread_create_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_remote_thread_create_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_remote_thread_create_t),
            "::",
            stringify!(thread_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_remote_thread_create_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has called setuid().\n\n @field uid The uid argument to the setuid() syscall.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setuid_t {
    pub uid: uid_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setuid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setuid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setuid_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_setuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_setuid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setuid_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setuid_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has called setgid().\n\n @field gid The gid argument to the setgid() syscall.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setgid_t {
    pub gid: uid_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setgid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setgid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setgid_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_setgid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_setgid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setgid_t),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setgid_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has called seteuid().\n\n @field euid The euid argument to the seteuid() syscall.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_seteuid_t {
    pub euid: uid_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_seteuid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_seteuid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_seteuid_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_seteuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_seteuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_seteuid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).euid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_seteuid_t),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_seteuid_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has called setegid().\n\n @field egid The egid argument to the setegid() syscall.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setegid_t {
    pub egid: uid_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setegid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setegid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setegid_t>(),
        68usize,
        concat!("Size of: ", stringify!(es_event_setegid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setegid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_setegid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).egid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setegid_t),
            "::",
            stringify!(egid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setegid_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has called setreuid().\n\n @field ruid The ruid argument to the setreuid() syscall.\n @field euid The euid argument to the setreuid() syscall.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setreuid_t {
    pub ruid: uid_t,
    pub euid: uid_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setreuid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setreuid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setreuid_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_setreuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setreuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_setreuid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ruid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setreuid_t),
            "::",
            stringify!(ruid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).euid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setreuid_t),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setreuid_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Notification that a process has called setregid().\n\n @field rgid The rgid argument to the setregid() syscall.\n @field egid The egid argument to the setregid() syscall.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_setregid_t {
    pub rgid: uid_t,
    pub egid: uid_t,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_es_event_setregid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_setregid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_setregid_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_setregid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_setregid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_setregid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setregid_t),
            "::",
            stringify!(rgid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).egid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setregid_t),
            "::",
            stringify!(egid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_setregid_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief OpenDirectory authentication data for type ES_AUTHENTICATION_TYPE_OD.\n\n @field instigator        Process that instigated the authentication\n                          (XPC caller that asked for authentication).\n @field record_type       OD record type against which OD is authenticating.\n                          Typically \"Users\", but other record types can auth too.\n @field record_name       OD record name against which OD is authenticating.\n                          For record type \"Users\", this is the username.\n @field node_name         OD node against which OD is authenticating.\n                          Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                          \"/Active Directory/<domain>\".\n @field db_path           Optional.  If node_name is \"/Local/Default\", this is\n                          the path of the database against which OD is\n                          authenticating."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_authentication_od_t {
    pub instigator: *mut es_process_t,
    pub record_type: es_string_token_t,
    pub record_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_authentication_od_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_od_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_od_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_authentication_od_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_od_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_authentication_od_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_od_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_od_t),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_od_t),
            "::",
            stringify!(record_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_od_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_od_t),
            "::",
            stringify!(db_path)
        )
    );
}
pub const es_touchid_mode_t_ES_TOUCHID_MODE_VERIFICATION: es_touchid_mode_t = 0;
pub const es_touchid_mode_t_ES_TOUCHID_MODE_IDENTIFICATION: es_touchid_mode_t = 1;
pub type es_touchid_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief TouchID authentication data for type ES_AUTHENTICATION_TYPE_TOUCHID.\n\n @field instigator        Process that instigated the authentication\n                          (XPC caller that asked for authentication).\n @field touchid_mode      TouchID authentication type\n @field has_uid           Describes whether or not the uid of the user authenticated is available\n @field uid               Union that is valid when `has_uid` is set to `true`\n @field uid.uid           uid of user that was authenticated.\n                          This will be set when `success` is true and `touchid_mode` is of\n                          verification type i.e. ES_TOUCHID_MODE_VERIFICATION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_authentication_touchid_t {
    pub instigator: *mut es_process_t,
    pub touchid_mode: es_touchid_mode_t,
    pub has_uid: bool,
    pub uid: es_event_authentication_touchid_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_authentication_touchid_t__bindgen_ty_1 {
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_authentication_touchid_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_touchid_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_touchid_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(es_event_authentication_touchid_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_touchid_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_authentication_touchid_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_touchid_t__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_authentication_touchid_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_touchid_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_touchid_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_authentication_touchid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_touchid_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_authentication_touchid_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_touchid_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).touchid_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_touchid_t),
            "::",
            stringify!(touchid_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_uid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_touchid_t),
            "::",
            stringify!(has_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_touchid_t),
            "::",
            stringify!(uid)
        )
    );
}
#[doc = " @brief Token authentication data for type ES_AUTHENTICATION_TYPE_TOKEN.\n\n @field instigator        Process that instigated the authentication\n                          (XPC caller that asked for authentication).\n @field pubkey_hash       Hash of the public key which CryptoTokenKit is authenticating.\n @field token_id          Token identifier of the event which CryptoTokenKit is authenticating.\n @field kerberos_principal Optional.  This will be available if token is used for GSS PKINIT\n                          authentication for obtaining a kerberos TGT.  NULL in all other cases."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_authentication_token_t {
    pub instigator: *mut es_process_t,
    pub pubkey_hash: es_string_token_t,
    pub token_id: es_string_token_t,
    pub kerberos_principal: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_authentication_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_token_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_token_t>(),
        56usize,
        concat!("Size of: ", stringify!(es_event_authentication_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_token_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_authentication_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_token_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pubkey_hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_token_t),
            "::",
            stringify!(pubkey_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_token_t),
            "::",
            stringify!(token_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kerberos_principal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_token_t),
            "::",
            stringify!(kerberos_principal)
        )
    );
}
#[doc = " Unlock the machine using Apple Watch."]
pub const es_auto_unlock_type_t_ES_AUTO_UNLOCK_MACHINE_UNLOCK: es_auto_unlock_type_t = 1;
#[doc = " Approve an authorization prompt using Apple Watch."]
pub const es_auto_unlock_type_t_ES_AUTO_UNLOCK_AUTH_PROMPT: es_auto_unlock_type_t = 2;
pub type es_auto_unlock_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Auto Unlock authentication data for type ES_AUTHENTICATION_TYPE_TOKEN.\n\n @field username          Username for which the authentication was attempted.\n @field type              Purpose of the authentication.\n\n @note This kind of authentication is performed when authenticating to the local\n Mac using an Apple Watch for the purpose of unlocking the machine or confirming\n an authorization prompt.  Auto Unlock is part of Continuity.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_authentication_auto_unlock_t {
    pub username: es_string_token_t,
    pub type_: es_auto_unlock_type_t,
}
#[test]
fn bindgen_test_layout_es_event_authentication_auto_unlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_auto_unlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_auto_unlock_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(es_event_authentication_auto_unlock_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_auto_unlock_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_authentication_auto_unlock_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_auto_unlock_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_auto_unlock_t),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @brief Notification that an authentication was performed.\n\n @field success           True iff authentication was successful.\n @field type              The type of authentication.\n @field data              Type-specific data describing the authentication.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_authentication_t {
    pub success: bool,
    pub type_: es_authentication_type_t,
    pub data: es_event_authentication_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_authentication_t__bindgen_ty_1 {
    pub od: *mut es_event_authentication_od_t,
    pub touchid: *mut es_event_authentication_touchid_t,
    pub token: *mut es_event_authentication_token_t,
    pub auto_unlock: *mut es_event_authentication_auto_unlock_t,
}
#[test]
fn bindgen_test_layout_es_event_authentication_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(es_event_authentication_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_authentication_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t__bindgen_ty_1),
            "::",
            stringify!(od)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).touchid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t__bindgen_ty_1),
            "::",
            stringify!(touchid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t__bindgen_ty_1),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auto_unlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t__bindgen_ty_1),
            "::",
            stringify!(auto_unlock)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_authentication_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authentication_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authentication_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_event_authentication_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authentication_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_authentication_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authentication_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief Notification that XProtect detected malware.\n\n @field signature_version     Version of the signatures used for detection.\n                              Currently corresponds to XProtect version.\n @field malware_identifier    String identifying the malware that was detected.\n @field incident_identifier   String identifying the incident, intended for linking\n                              multiple malware detected and remediated events.\n @field detected_path         Path where malware was detected.  This path is not\n                              necessarily a malicious binary, it can also be a\n                              legitimate file containing a malicious portion.\n\n @note For any given malware incident, XProtect may emit zero or more\n       xp_malware_detected events, and zero or more xp_malware_remediated events.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_xp_malware_detected_t {
    pub signature_version: es_string_token_t,
    pub malware_identifier: es_string_token_t,
    pub incident_identifier: es_string_token_t,
    pub detected_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_xp_malware_detected_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_xp_malware_detected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_xp_malware_detected_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_xp_malware_detected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_xp_malware_detected_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_xp_malware_detected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_detected_t),
            "::",
            stringify!(signature_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malware_identifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_detected_t),
            "::",
            stringify!(malware_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incident_identifier) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_detected_t),
            "::",
            stringify!(incident_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detected_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_detected_t),
            "::",
            stringify!(detected_path)
        )
    );
}
#[doc = " @brief Notification that XProtect remediated malware.\n\n @field signature_version     Version of the signatures used for remediation.\n                              Currently corresponds to XProtect version.\n @field malware_identifier    String identifying the malware that was detected.\n @field incident_identifier   String identifying the incident, intended for linking\n                              multiple malware detected and remediated events.\n @field action_type           String indicating the type of action that was taken,\n                              e.g. \"path_delete\".\n @field success               True iff remediation was successful.\n @field result_description    String describing specific reasons for failure or success.\n @field remediated_path       Optional.  Path that was subject to remediation, if any.\n                              This path is not necessarily a malicious binary, it can\n                              also be a legitimate file containing a malicious portion.\n                              Specifically, the file at this path may still exist after\n                              successful remediation.\n @field remediated_process_audit_token  Audit token of process that was subject to\n                              remediation, if any.\n\n @note For any given malware incident, XProtect may emit zero or more\n       xp_malware_detected events, and zero or more xp_malware_remediated events.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_xp_malware_remediated_t {
    pub signature_version: es_string_token_t,
    pub malware_identifier: es_string_token_t,
    pub incident_identifier: es_string_token_t,
    pub action_type: es_string_token_t,
    pub success: bool,
    pub result_description: es_string_token_t,
    pub remediated_path: es_string_token_t,
    pub remediated_process_audit_token: *mut audit_token_t,
}
#[test]
fn bindgen_test_layout_es_event_xp_malware_remediated_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_xp_malware_remediated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_xp_malware_remediated_t>(),
        112usize,
        concat!("Size of: ", stringify!(es_event_xp_malware_remediated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_xp_malware_remediated_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_xp_malware_remediated_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(signature_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malware_identifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(malware_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incident_identifier) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(incident_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(action_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_description) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(result_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remediated_path) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(remediated_path)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).remediated_process_audit_token) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xp_malware_remediated_t),
            "::",
            stringify!(remediated_process_audit_token)
        )
    );
}
#[doc = " @brief es_graphical_session_id_t is a session identifier identifying a on-console or off-console graphical session.\n A graphical session exists and can potentially be attached to via Screen Sharing before a user is logged in.\n EndpointSecurity clients should treat the `graphical_session_id` as an opaque identifier and not assign\n special meaning to it beyond correlating events pertaining to the same graphical session.  Not to be confused with the audit session ID."]
pub type es_graphical_session_id_t = u32;
#[doc = " @brief Notification that LoginWindow has logged in a user.\n\n @field username              Short username of the user.\n @field graphical_session_id  Graphical session id of the session.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_lw_session_login_t {
    pub username: es_string_token_t,
    pub graphical_session_id: es_graphical_session_id_t,
}
#[test]
fn bindgen_test_layout_es_event_lw_session_login_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_lw_session_login_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_lw_session_login_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_lw_session_login_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_lw_session_login_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_lw_session_login_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_login_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphical_session_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_login_t),
            "::",
            stringify!(graphical_session_id)
        )
    );
}
#[doc = " @brief Notification that LoginWindow has logged out a user.\n\n @field username              Short username of the user.\n @field graphical_session_id  Graphical session id of the session.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_lw_session_logout_t {
    pub username: es_string_token_t,
    pub graphical_session_id: es_graphical_session_id_t,
}
#[test]
fn bindgen_test_layout_es_event_lw_session_logout_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_lw_session_logout_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_lw_session_logout_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_lw_session_logout_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_lw_session_logout_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_lw_session_logout_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_logout_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphical_session_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_logout_t),
            "::",
            stringify!(graphical_session_id)
        )
    );
}
#[doc = " @brief Notification that LoginWindow locked the screen of a session.\n\n @field username              Short username of the user.\n @field graphical_session_id  Graphical session id of the session.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_lw_session_lock_t {
    pub username: es_string_token_t,
    pub graphical_session_id: es_graphical_session_id_t,
}
#[test]
fn bindgen_test_layout_es_event_lw_session_lock_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_lw_session_lock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_lw_session_lock_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_lw_session_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_lw_session_lock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_lw_session_lock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_lock_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphical_session_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_lock_t),
            "::",
            stringify!(graphical_session_id)
        )
    );
}
#[doc = " @brief Notification that LoginWindow unlocked the screen of a session.\n\n @field username              Short username of the user.\n @field graphical_session_id  Graphical session id of the session.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_lw_session_unlock_t {
    pub username: es_string_token_t,
    pub graphical_session_id: es_graphical_session_id_t,
}
#[test]
fn bindgen_test_layout_es_event_lw_session_unlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_lw_session_unlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_lw_session_unlock_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_lw_session_unlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_lw_session_unlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_lw_session_unlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_unlock_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphical_session_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_lw_session_unlock_t),
            "::",
            stringify!(graphical_session_id)
        )
    );
}
#[doc = " @brief Notification that Screen Sharing has attached to a graphical session.\n\n @field success               True iff Screen Sharing successfully attached.\n @field source_address_type   Type of source address.\n @field source_address        Optional.  Source address of connection, or NULL.\n                              Depending on the transport used, the source\n                              address may or may not be available.\n @field viewer_appleid        Optional.  For screen sharing initiated using an\n                              Apple ID (e.g., from Messages or FaceTime), this\n                              is the viewer's (client's) Apple ID.  It is not\n                              necessarily the Apple ID that invited the screen\n                              sharing.  NULL if unavailable.\n @field authentication_type   Type of authentication.\n @field authentication_username  Optional.  Username used for authentication to\n                              Screen Sharing.  NULL if authentication type doesn't\n                              use an username (e.g. simple VNC password).\n @field session_username      Optional.  Username of the loginwindow session if\n                              available,  NULL otherwise.\n @field existing_session      True iff there was an existing user session.\n @field graphical_session_id  Graphical session id of the screen shared.\n\n @note This event type does not support caching (notify-only).\n @discussion This event is not emitted when a screensharing session has the same source and destination address.\n For example if device A is acting as a NAT gateway for device B, then a screensharing session from B -> A would not emit an event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_screensharing_attach_t {
    pub success: bool,
    pub source_address_type: es_address_type_t,
    pub source_address: es_string_token_t,
    pub viewer_appleid: es_string_token_t,
    pub authentication_type: es_string_token_t,
    pub authentication_username: es_string_token_t,
    pub session_username: es_string_token_t,
    pub existing_session: bool,
    pub graphical_session_id: es_graphical_session_id_t,
}
#[test]
fn bindgen_test_layout_es_event_screensharing_attach_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_screensharing_attach_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_screensharing_attach_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_screensharing_attach_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_screensharing_attach_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_screensharing_attach_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(source_address_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewer_appleid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(viewer_appleid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(authentication_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_username) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(authentication_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_username) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(session_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).existing_session) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(existing_session)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphical_session_id) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_attach_t),
            "::",
            stringify!(graphical_session_id)
        )
    );
}
#[doc = " @brief Notification that Screen Sharing has detached from a graphical session.\n\n @field source_address_type   Type of source address.\n @field source_address        Optional.  Source address of connection, or NULL.\n                              Depending on the transport used, the source\n                              address may or may not be available.\n @field viewer_appleid        Optional.  For screen sharing initiated using an\n                              Apple ID (e.g., from Messages or FaceTime), this\n                              is the viewer's (client's) Apple ID.  It is not\n                              necessarily the Apple ID that invited the screen\n                              sharing.  NULL if unavailable.\n @field graphical_session_id  Graphical session id of the screen shared.\n\n @note This event type does not support caching (notify-only).\n @discussion This event is not emitted when a screensharing session has the same source and destination address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_screensharing_detach_t {
    pub source_address_type: es_address_type_t,
    pub source_address: es_string_token_t,
    pub viewer_appleid: es_string_token_t,
    pub graphical_session_id: es_graphical_session_id_t,
}
#[test]
fn bindgen_test_layout_es_event_screensharing_detach_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_screensharing_detach_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_screensharing_detach_t>(),
        48usize,
        concat!("Size of: ", stringify!(es_event_screensharing_detach_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_screensharing_detach_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_screensharing_detach_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_detach_t),
            "::",
            stringify!(source_address_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_detach_t),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewer_appleid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_detach_t),
            "::",
            stringify!(viewer_appleid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphical_session_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_screensharing_detach_t),
            "::",
            stringify!(graphical_session_id)
        )
    );
}
pub const es_openssh_login_result_type_t_ES_OPENSSH_LOGIN_EXCEED_MAXTRIES:
    es_openssh_login_result_type_t = 0;
pub const es_openssh_login_result_type_t_ES_OPENSSH_LOGIN_ROOT_DENIED:
    es_openssh_login_result_type_t = 1;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_SUCCESS: es_openssh_login_result_type_t =
    2;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_FAIL_NONE: es_openssh_login_result_type_t =
    3;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_FAIL_PASSWD:
    es_openssh_login_result_type_t = 4;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_FAIL_KBDINT:
    es_openssh_login_result_type_t = 5;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_FAIL_PUBKEY:
    es_openssh_login_result_type_t = 6;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_FAIL_HOSTBASED:
    es_openssh_login_result_type_t = 7;
pub const es_openssh_login_result_type_t_ES_OPENSSH_AUTH_FAIL_GSSAPI:
    es_openssh_login_result_type_t = 8;
pub const es_openssh_login_result_type_t_ES_OPENSSH_INVALID_USER: es_openssh_login_result_type_t =
    9;
pub type es_openssh_login_result_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Notification for OpenSSH login event.\n\n @field success               True iff login was successful.\n @field result_type           Result type for the login attempt.\n @field source_address_type   Type of source address.\n @field source_address        Source address of connection.\n @field username              Username used for login.\n @field has_uid               Describes whether or not the uid of the user logged in is available\n @field uid                   Union that is valid when `has_uid` is set to `true`\n @field uid.uid               uid of user that was logged in.\n\n @note This is a connection-level event.  An SSH connection that is used\n for multiple interactive sessions and/or non-interactive commands will\n emit only a single successful login event.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_openssh_login_t {
    pub success: bool,
    pub result_type: es_openssh_login_result_type_t,
    pub source_address_type: es_address_type_t,
    pub source_address: es_string_token_t,
    pub username: es_string_token_t,
    pub has_uid: bool,
    pub uid: es_event_openssh_login_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_openssh_login_t__bindgen_ty_1 {
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_openssh_login_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_openssh_login_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_openssh_login_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(es_event_openssh_login_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_openssh_login_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_openssh_login_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_openssh_login_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_openssh_login_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_openssh_login_t>(),
        56usize,
        concat!("Size of: ", stringify!(es_event_openssh_login_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_openssh_login_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_openssh_login_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(result_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(source_address_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_uid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(has_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_login_t),
            "::",
            stringify!(uid)
        )
    );
}
#[doc = " @brief Notification for OpenSSH logout event.\n\n @field source_address_type   Type of address used in the connection.\n @field source_address        Source address of the connection.\n @field username              Username which got logged out.\n @field uid                   uid of user that was logged out.\n\n @note This is a connection-level event.  An SSH connection that is used\n for multiple interactive sessions and/or non-interactive commands will\n emit only a single logout event.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_openssh_logout_t {
    pub source_address_type: es_address_type_t,
    pub source_address: es_string_token_t,
    pub username: es_string_token_t,
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_openssh_logout_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_openssh_logout_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_openssh_logout_t>(),
        48usize,
        concat!("Size of: ", stringify!(es_event_openssh_logout_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_openssh_logout_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_openssh_logout_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_logout_t),
            "::",
            stringify!(source_address_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_logout_t),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_logout_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_openssh_logout_t),
            "::",
            stringify!(uid)
        )
    );
}
#[doc = " @brief Notification for authenticated login event from /usr/bin/login.\n\n @field success               True iff login was successful.\n @field failure_message       Optional. Failure message generated.\n @field username              Username used for login.\n @field has_uid               Describes whether or not the uid of the user logged in is available or not.\n @field uid                   Union that is valid when `has_uid` is set to `true`\n @field uid.uid               uid of user that was logged in.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_login_login_t {
    pub success: bool,
    pub failure_message: es_string_token_t,
    pub username: es_string_token_t,
    pub has_uid: bool,
    pub uid: es_event_login_login_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_login_login_t__bindgen_ty_1 {
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_login_login_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_login_login_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_login_login_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(es_event_login_login_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_login_login_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_login_login_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_login_t__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_login_login_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_login_login_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_login_login_t>(),
        48usize,
        concat!("Size of: ", stringify!(es_event_login_login_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_login_login_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_login_login_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_login_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failure_message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_login_t),
            "::",
            stringify!(failure_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_login_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_uid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_login_t),
            "::",
            stringify!(has_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_login_t),
            "::",
            stringify!(uid)
        )
    );
}
#[doc = " @brief Notification for authenticated logout event from /usr/bin/login.\n\n @field username              Username used for login.\n @field uid                   uid of user that was logged in.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_login_logout_t {
    pub username: es_string_token_t,
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_login_logout_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_login_logout_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_login_logout_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_login_logout_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_login_logout_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_login_logout_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_logout_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_login_logout_t),
            "::",
            stringify!(uid)
        )
    );
}
#[doc = " @brief Notification for launch item being made known to background\n        task management.  This includes launch agents and daemons as\n        well as login items added by the user, via MDM or by an app.\n\n @field instigator            Optional.  Process that instigated the BTM operation\n                              (XPC caller that asked for the item to be added).\n @field app                   Optional.  App process that registered the item.\n @field item                  BTM launch item.\n @field executable_path       Optional.  If available and applicable, the POSIX executable\n                              path from the launchd plist.\n                              If the path is relative, it is relative to item->app_url.\n\n @note May be emitted for items where an add was already seen previously,\n       with or without the item having changed.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_btm_launch_item_add_t {
    pub instigator: *mut es_process_t,
    pub app: *mut es_process_t,
    pub item: *mut es_btm_launch_item_t,
    pub executable_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_btm_launch_item_add_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_btm_launch_item_add_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_btm_launch_item_add_t>(),
        40usize,
        concat!("Size of: ", stringify!(es_event_btm_launch_item_add_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_btm_launch_item_add_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_btm_launch_item_add_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_add_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_add_t),
            "::",
            stringify!(app)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_add_t),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).executable_path) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_add_t),
            "::",
            stringify!(executable_path)
        )
    );
}
#[doc = " @brief Notification for launch item being removed from background\n        task management.  This includes launch agents and daemons as\n        well as login items added by the user, via MDM or by an app.\n\n @field instigator            Optional.  Process that instigated the BTM operation\n                              (XPC caller that asked for the item to be removed).\n @field app                   Optional.  App process that registered the item.\n @field item                  BTM launch item.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_btm_launch_item_remove_t {
    pub instigator: *mut es_process_t,
    pub app: *mut es_process_t,
    pub item: *mut es_btm_launch_item_t,
}
#[test]
fn bindgen_test_layout_es_event_btm_launch_item_remove_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_btm_launch_item_remove_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_btm_launch_item_remove_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_btm_launch_item_remove_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_btm_launch_item_remove_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_btm_launch_item_remove_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_remove_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_remove_t),
            "::",
            stringify!(app)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_btm_launch_item_remove_t),
            "::",
            stringify!(item)
        )
    );
}
#[doc = " @brief Notification for a su policy decisions events.\n\n @field success           True iff su was successful.\n @field failure_message   Optional. If success is false, a failure message is contained in this field\n @field from_uid          The uid of the user who initiated the su\n @field from_name         The name of the user who initiated the su\n @field has_to_uid        True iff su was successful, Describes whether or not the to_uid is interpretable\n @field to_uid            Optional. If success, the user ID that is going to be substituted\n @field to_username       Optional. If success, the user name that is going to be substituted\n @field shell             Optional. If success, the shell is going to execute\n @field argc              The length of argv\n @field argv              If success, the arguments are passed into to the shell\n @field env_count         The length of env\n @field env               If success, list of environment variables that is going to be substituted\n\n @note This event type does not support caching (notify-only). Should always\n emit on success but will only emit on security relevant failures. For example,\n Endpoint Security clients will not get an event for su being passed invalid\n command line arguments.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_su_t {
    pub success: bool,
    pub failure_message: es_string_token_t,
    pub from_uid: uid_t,
    pub from_username: es_string_token_t,
    pub has_to_uid: bool,
    pub to_uid: es_event_su_t__bindgen_ty_1,
    pub to_username: es_string_token_t,
    pub shell: es_string_token_t,
    pub argc: usize,
    pub argv: *mut es_string_token_t,
    pub env_count: usize,
    pub env: *mut es_string_token_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_su_t__bindgen_ty_1 {
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_su_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_su_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_su_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(es_event_su_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_su_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_su_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_su_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_su_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_su_t>(),
        120usize,
        concat!("Size of: ", stringify!(es_event_su_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_su_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_su_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failure_message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(failure_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_uid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(from_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_username) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(from_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_to_uid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(has_to_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_uid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(to_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_username) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(to_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shell) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(shell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).env_count) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(env_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).env) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_su_t),
            "::",
            stringify!(env)
        )
    );
}
pub const es_sudo_plugin_type_t_ES_SUDO_PLUGIN_TYPE_UNKNOWN: es_sudo_plugin_type_t = 0;
pub const es_sudo_plugin_type_t_ES_SUDO_PLUGIN_TYPE_FRONT_END: es_sudo_plugin_type_t = 1;
pub const es_sudo_plugin_type_t_ES_SUDO_PLUGIN_TYPE_POLICY: es_sudo_plugin_type_t = 2;
pub const es_sudo_plugin_type_t_ES_SUDO_PLUGIN_TYPE_IO: es_sudo_plugin_type_t = 3;
pub const es_sudo_plugin_type_t_ES_SUDO_PLUGIN_TYPE_AUDIT: es_sudo_plugin_type_t = 4;
pub const es_sudo_plugin_type_t_ES_SUDO_PLUGIN_TYPE_APPROVAL: es_sudo_plugin_type_t = 5;
#[doc = " @brief This enum describes the type of plugin types in sudo"]
pub type es_sudo_plugin_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Provides context about failures in es_event_sudo_t.\n\n @field plugin_name      The sudo plugin that initiated the reject\n @field plugin_type      The sudo plugin type that initiated the reject\n @field failure_message  A reason represented by a string for the failure\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_sudo_reject_info_t {
    pub plugin_name: es_string_token_t,
    pub plugin_type: es_sudo_plugin_type_t,
    pub failure_message: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_sudo_reject_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_sudo_reject_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_sudo_reject_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(es_sudo_reject_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_sudo_reject_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_sudo_reject_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plugin_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_sudo_reject_info_t),
            "::",
            stringify!(plugin_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plugin_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_sudo_reject_info_t),
            "::",
            stringify!(plugin_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failure_message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_sudo_reject_info_t),
            "::",
            stringify!(failure_message)
        )
    );
}
#[doc = " @brief Notification for a sudo event.\n\n @field success          True iff sudo was successful\n @field reject_info      Optional. When success is false, describes why sudo was rejected\n @field has_from_uid     Describes whether or not the from_uid is interpretable\n @field from_uid         Optional. The uid of the user who initiated the su\n @field from_name        Optional. The name of the user who initiated the su\n @field has_to_uid       Describes whether or not the to_uid is interpretable\n @field to_uid           Optional. If success, the user ID that is going to be substituted\n @field to_username      Optional. If success, the user name that is going to be substituted\n @field command          Optional. The command to be run\n\n @note This event type does not support caching (notify-only).\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_event_sudo_t {
    pub success: bool,
    pub reject_info: *mut es_sudo_reject_info_t,
    pub has_from_uid: bool,
    pub from_uid: es_event_sudo_t__bindgen_ty_1,
    pub from_username: es_string_token_t,
    pub has_to_uid: bool,
    pub to_uid: es_event_sudo_t__bindgen_ty_2,
    pub to_username: es_string_token_t,
    pub command: es_string_token_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_sudo_t__bindgen_ty_1 {
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_sudo_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_sudo_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_sudo_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(es_event_sudo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_sudo_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_sudo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_event_sudo_t__bindgen_ty_2 {
    pub uid: uid_t,
}
#[test]
fn bindgen_test_layout_es_event_sudo_t__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_sudo_t__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_sudo_t__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(es_event_sudo_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_sudo_t__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(es_event_sudo_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t__bindgen_ty_2),
            "::",
            stringify!(uid)
        )
    );
}
#[test]
fn bindgen_test_layout_es_event_sudo_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_sudo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_sudo_t>(),
        80usize,
        concat!("Size of: ", stringify!(es_event_sudo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_sudo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_sudo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reject_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(reject_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_from_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(has_from_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_uid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(from_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_username) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(from_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_to_uid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(has_to_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_uid) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(to_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_username) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(to_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_sudo_t),
            "::",
            stringify!(command)
        )
    );
}
#[doc = " @brief Notification for Profiles installed on the system.\n\n @field instigator            Process that instigated the Profile install or update.\n @field is_update             Indicates if the profile is an update to an already installed\n                                 profile.\n @field item                  Profile install item.\n\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_profile_add_t {
    pub instigator: *mut es_process_t,
    pub is_update: bool,
    pub profile: *mut es_profile_t,
}
#[test]
fn bindgen_test_layout_es_event_profile_add_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_profile_add_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_profile_add_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_profile_add_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_profile_add_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_profile_add_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_profile_add_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_update) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_profile_add_t),
            "::",
            stringify!(is_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_profile_add_t),
            "::",
            stringify!(profile)
        )
    );
}
#[doc = " @brief Notification for Profiles removed on the system.\n @field instigator            Process that instigated the Profile removal.\n @field item                  Profile being removed.\n\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_profile_remove_t {
    pub instigator: *mut es_process_t,
    pub profile: *mut es_profile_t,
}
#[test]
fn bindgen_test_layout_es_event_profile_remove_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_profile_remove_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_profile_remove_t>(),
        16usize,
        concat!("Size of: ", stringify!(es_event_profile_remove_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_profile_remove_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_profile_remove_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_profile_remove_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_profile_remove_t),
            "::",
            stringify!(profile)
        )
    );
}
#[doc = " @brief Notification that a process peititioned for certain authorization rights\n\n @field instigator            Process that submitted the petition (XPC caller)\n @field petitioner            Process that created the petition\n @field flags                 Flags associated with the petition. Defined Security framework \"Authorization/Authorizatioh.h\"\n @field right_count           The number of elements in `rights`\n @field rights                Array of string tokens, each token is the name of a right being requested\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_authorization_petition_t {
    pub instigator: *mut es_process_t,
    pub petitioner: *mut es_process_t,
    pub flags: u32,
    pub right_count: usize,
    pub rights: *mut es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_authorization_petition_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authorization_petition_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authorization_petition_t>(),
        40usize,
        concat!("Size of: ", stringify!(es_event_authorization_petition_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authorization_petition_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_authorization_petition_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_petition_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).petitioner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_petition_t),
            "::",
            stringify!(petitioner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_petition_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_petition_t),
            "::",
            stringify!(right_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rights) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_petition_t),
            "::",
            stringify!(rights)
        )
    );
}
#[doc = " @brief Describes, for a single right, the class of that right and if it was granted\n\n @field right_name            The name of the right being considered\n @field rule_class            The class of the right being considered\n                              The rule class determines how the operating system determines\n                              if it should be granted or not\n @field granted               Indicates if the right was granted or not"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_authorization_result_t {
    pub right_name: es_string_token_t,
    pub rule_class: es_authorization_rule_class_t,
    pub granted: bool,
}
#[test]
fn bindgen_test_layout_es_authorization_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_authorization_result_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_authorization_result_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_authorization_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_authorization_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_authorization_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_authorization_result_t),
            "::",
            stringify!(right_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rule_class) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_authorization_result_t),
            "::",
            stringify!(rule_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granted) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(es_authorization_result_t),
            "::",
            stringify!(granted)
        )
    );
}
#[doc = " @brief Notification that a process had it's right petition judged\n\n @field instigator            Process that submitted the petition (XPC caller)\n @field petitioner            Process that created the petition\n @field return_code           The overall result of the petition. 0 indicates success.\n                              Possible return codes are defined Security framework \"Authorization/Authorizatioh.h\"\n @field result_count          The number of elements in `results`\n @field results               Array of results. One for each right that was peititioned\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_authorization_judgement_t {
    pub instigator: *mut es_process_t,
    pub petitioner: *mut es_process_t,
    pub return_code: ::std::os::raw::c_int,
    pub result_count: usize,
    pub results: *mut es_authorization_result_t,
}
#[test]
fn bindgen_test_layout_es_event_authorization_judgement_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_authorization_judgement_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_authorization_judgement_t>(),
        40usize,
        concat!("Size of: ", stringify!(es_event_authorization_judgement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_authorization_judgement_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_authorization_judgement_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_judgement_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).petitioner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_judgement_t),
            "::",
            stringify!(petitioner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_code) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_judgement_t),
            "::",
            stringify!(return_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_judgement_t),
            "::",
            stringify!(result_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).results) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_authorization_judgement_t),
            "::",
            stringify!(results)
        )
    );
}
#[doc = " @brief The identity of a group member\n\n @field member_type    Indicates the type of the member, and how it is identified.\n                       Note that member_type indicates which field of member_value is initialised.\n @field member_value   The member identity."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_od_member_id_t {
    pub member_type: es_od_member_type_t,
    pub member_value: es_od_member_id_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_od_member_id_t__bindgen_ty_1 {
    pub uuid: uuid_t,
    pub name: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_od_member_id_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_od_member_id_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_od_member_id_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(es_od_member_id_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_od_member_id_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(es_od_member_id_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_t__bindgen_ty_1),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_t__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_es_od_member_id_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_od_member_id_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_od_member_id_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_od_member_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_od_member_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_od_member_id_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_t),
            "::",
            stringify!(member_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_t),
            "::",
            stringify!(member_value)
        )
    );
}
#[doc = " @brief Notification that a member was added to a group.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field group_name   The group to which the member was added.\n @field member       The identity of the member added.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only).\n @note This event does not indicate that a member was actually added.\n       For example when adding a user to a group they are already a member of."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_group_add_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub group_name: es_string_token_t,
    pub member: *mut es_od_member_id_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_group_add_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_group_add_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_group_add_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_od_group_add_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_group_add_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_group_add_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_add_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_add_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_add_t),
            "::",
            stringify!(group_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_add_t),
            "::",
            stringify!(member)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_add_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_add_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a member was removed from a group.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field group_name   The group from which the member was removed.\n @field member       The identity of the member removed.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only).\n @note This event does not indicate that a member was actually removed.\n       For example when removing a user from a group they are not a member of."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_group_remove_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub group_name: es_string_token_t,
    pub member: *mut es_od_member_id_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_group_remove_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_group_remove_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_group_remove_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_od_group_remove_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_group_remove_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_group_remove_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_remove_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_remove_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_remove_t),
            "::",
            stringify!(group_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_remove_t),
            "::",
            stringify!(member)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_remove_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_remove_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief An array of group member identities.\n\n @field member_type    Indicates the type of the members, and how they are identified.\n                       Note that member_type indicates which field of member_array is initialised.\n @field member_count   The number of elements in member_array.\n @field member_array   A union of pointers.\n                       The initialised member points to the first element of an array of member values."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_od_member_id_array_t {
    pub member_type: es_od_member_type_t,
    pub member_count: usize,
    pub member_array: es_od_member_id_array_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_od_member_id_array_t__bindgen_ty_1 {
    pub uuids: *mut uuid_t,
    pub names: *mut es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_od_member_id_array_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_od_member_id_array_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_od_member_id_array_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(es_od_member_id_array_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_od_member_id_array_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_od_member_id_array_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_array_t__bindgen_ty_1),
            "::",
            stringify!(uuids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_array_t__bindgen_ty_1),
            "::",
            stringify!(names)
        )
    );
}
#[test]
fn bindgen_test_layout_es_od_member_id_array_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_od_member_id_array_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_od_member_id_array_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_od_member_id_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_od_member_id_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_od_member_id_array_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_array_t),
            "::",
            stringify!(member_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_array_t),
            "::",
            stringify!(member_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).member_array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_od_member_id_array_t),
            "::",
            stringify!(member_array)
        )
    );
}
#[doc = " @brief Notification that a group had it's members initialised or replaced.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field group_name   The group for which members were set.\n @field members      Array of new members.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only).\n @note This event does not indicate that a member was actually removed.\n       For example when removing a user from a group they are not a member of."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_group_set_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub group_name: es_string_token_t,
    pub members: *mut es_od_member_id_array_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_group_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_group_set_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_group_set_t>(),
        72usize,
        concat!("Size of: ", stringify!(es_event_od_group_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_group_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_group_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_set_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_set_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_set_t),
            "::",
            stringify!(group_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).members) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_set_t),
            "::",
            stringify!(members)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_set_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_group_set_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that an account had its password modified.\n\n @field instigator     Process that instigated operation (XPC caller).\n @field error_code     0 indicates the operation succeeded.\n                       Values inidicating specific failure reasons are defined in odconstants.h.\n @field account_type   The type of the account for which the password was modified.\n @field account_name   The name of the account for which the password was modified.\n @field node_name      OD node being mutated.\n                       Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                       \"/Active Directory/<domain>\".\n @field db_path        Optional.  If node_name is \"/Local/Default\", this is\n                       the path of the database against which OD is\n                       authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_modify_password_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub account_type: es_od_account_type_t,
    pub account_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_modify_password_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_modify_password_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_modify_password_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_modify_password_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_modify_password_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_modify_password_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_modify_password_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_modify_password_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).account_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_modify_password_t),
            "::",
            stringify!(account_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).account_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_modify_password_t),
            "::",
            stringify!(account_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_modify_password_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_modify_password_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a user account was disabled.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field user_name    The name of the user account that was disabled.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_disable_user_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub user_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_disable_user_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_disable_user_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_disable_user_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_disable_user_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_disable_user_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_disable_user_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_disable_user_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_disable_user_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_disable_user_t),
            "::",
            stringify!(user_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_disable_user_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_disable_user_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a user account was enabled.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field user_name    The name of the user account that was enabled.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_enable_user_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub user_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_enable_user_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_enable_user_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_enable_user_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_enable_user_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_enable_user_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_enable_user_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_enable_user_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_enable_user_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_enable_user_t),
            "::",
            stringify!(user_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_enable_user_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_enable_user_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that an attribute value was added to a record.\n\n @field instigator       Process that instigated operation (XPC caller).\n @field error_code       0 indicates the operation succeeded.\n                         Values inidicating specific failure reasons are defined in odconstants.h.\n @field record_type      The type of the record to which the attribute value was added.\n @field record_name      The name of the record to which the attribute value was added.\n @field attribute_name   The name of the attribute to which the value was added.\n @field attribute_value  The value that was added.\n @field node_name        OD node being mutated.\n                         Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                         \"/Active Directory/<domain>\".\n @field db_path          Optional.  If node_name is \"/Local/Default\", this is\n                         the path of the database against which OD is\n                         authenticating.\n\n @note This event type does not support caching (notify-only).\n @note Attributes conceptually have the type `Map String (Set String)`.\n       Each OD record has a Map of attribute name to Set of attribute value.\n       When an attribute value is added, it is inserted into the set of values for that name."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_attribute_value_add_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub record_type: es_od_record_type_t,
    pub record_name: es_string_token_t,
    pub attribute_name: es_string_token_t,
    pub attribute_value: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_attribute_value_add_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_attribute_value_add_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_attribute_value_add_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_od_attribute_value_add_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_attribute_value_add_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_od_attribute_value_add_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(record_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(attribute_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(attribute_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_add_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that an attribute value was removed from a record.\n\n @field instigator       Process that instigated operation (XPC caller).\n @field error_code       0 indicates the operation succeeded.\n                         Values inidicating specific failure reasons are defined in odconstants.h.\n @field record_type      The type of the record from which the attribute value was removed.\n @field record_name      The name of the record from which the attribute value was removed.\n @field attribute_name   The name of the attribute from which the value was removed.\n @field attribute_value  The value that was removed.\n @field node_name        OD node being mutated.\n                         Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                         \"/Active Directory/<domain>\".\n @field db_path          Optional.  If node_name is \"/Local/Default\", this is\n                         the path of the database against which OD is\n                         authenticating.\n\n @note This event type does not support caching (notify-only).\n @note Attributes conceptually have the type `Map String (Set String)`.\n       Each OD record has a Map of attribute name to Set of attribute value.\n       When an attribute value is removed, it is subtraced from the set of values for that name.\n @note Removing a value that was never added is a no-op."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_attribute_value_remove_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub record_type: es_od_record_type_t,
    pub record_name: es_string_token_t,
    pub attribute_name: es_string_token_t,
    pub attribute_value: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_attribute_value_remove_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_attribute_value_remove_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_attribute_value_remove_t>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(es_event_od_attribute_value_remove_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_attribute_value_remove_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(es_event_od_attribute_value_remove_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(record_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(attribute_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(attribute_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_value_remove_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that an attribute is being set.\n\n @field instigator              Process that instigated operation (XPC caller).\n @field error_code              0 indicates the operation succeeded.\n                                Values inidicating specific failure reasons are defined in odconstants.h.\n @field record_type             The type of the record for which the attribute is being set.\n @field record_name             The name of the record for which the attribute is being set.\n @field attribute_name          The name of the attribute that was set.\n @field attribute_value_count   The size of attribute_value_array.\n @field attribute_value_array   Array of attribute values that were set.\n @field node_name               OD node being mutated.\n                                Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                                \"/Active Directory/<domain>\".\n @field db_path                 Optional.  If node_name is \"/Local/Default\", this is\n                                the path of the database against which OD is\n                                authenticating.\n\n @note This event type does not support caching (notify-only).\n @note Attributes conceptually have the type `Map String (Set String)`.\n       Each OD record has a Map of attribute name to Set of attribute value.\n       An attribute set operation indicates the entire set of attribute values was replaced.\n @note The new set of attribute values may be empty."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_attribute_set_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub record_type: es_od_record_type_t,
    pub record_name: es_string_token_t,
    pub attribute_name: es_string_token_t,
    pub attribute_value_count: usize,
    pub attribute_values: *mut es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_attribute_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_attribute_set_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_attribute_set_t>(),
        96usize,
        concat!("Size of: ", stringify!(es_event_od_attribute_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_attribute_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_attribute_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(record_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(attribute_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_value_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(attribute_value_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute_values) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(attribute_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_attribute_set_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a user account was created.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field user_name    The name of the user account that was created.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_create_user_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub user_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_create_user_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_create_user_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_create_user_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_create_user_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_create_user_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_create_user_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_user_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_user_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_user_t),
            "::",
            stringify!(user_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_user_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_user_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a group was created.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field user_name    The name of the group that was created.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_create_group_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub group_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_create_group_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_create_group_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_create_group_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_create_group_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_create_group_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_create_group_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_group_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_group_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_group_t),
            "::",
            stringify!(group_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_group_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_create_group_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a user account was deleted.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field user_name    The name of the user account that was deleted.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_delete_user_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub user_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_delete_user_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_delete_user_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_delete_user_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_delete_user_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_delete_user_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_delete_user_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_user_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_user_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_user_t),
            "::",
            stringify!(user_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_user_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_user_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification that a group was deleted.\n\n @field instigator   Process that instigated operation (XPC caller).\n @field error_code   0 indicates the operation succeeded.\n                     Values inidicating specific failure reasons are defined in odconstants.h.\n @field user_name    The name of the group that was deleted.\n @field node_name    OD node being mutated.\n                     Typically one of \"/Local/Default\", \"/LDAPv3/<server>\" or\n                     \"/Active Directory/<domain>\".\n @field db_path      Optional.  If node_name is \"/Local/Default\", this is\n                     the path of the database against which OD is\n                     authenticating.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_od_delete_group_t {
    pub instigator: *mut es_process_t,
    pub error_code: ::std::os::raw::c_int,
    pub group_name: es_string_token_t,
    pub node_name: es_string_token_t,
    pub db_path: es_string_token_t,
}
#[test]
fn bindgen_test_layout_es_event_od_delete_group_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_od_delete_group_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_od_delete_group_t>(),
        64usize,
        concat!("Size of: ", stringify!(es_event_od_delete_group_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_od_delete_group_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_od_delete_group_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instigator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_group_t),
            "::",
            stringify!(instigator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_group_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_group_t),
            "::",
            stringify!(group_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_group_t),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_od_delete_group_t),
            "::",
            stringify!(db_path)
        )
    );
}
#[doc = " @brief Notification for an XPC connection being established to a named service.\n\n @field service_name          Service name of the named service.\n @field service_domain_type   The type of XPC domain in which the service resides in.\n\n @note This event type does not support caching (notify-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_event_xpc_connect_t {
    pub service_name: es_string_token_t,
    pub service_domain_type: es_xpc_domain_type_t,
}
#[test]
fn bindgen_test_layout_es_event_xpc_connect_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_event_xpc_connect_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_event_xpc_connect_t>(),
        24usize,
        concat!("Size of: ", stringify!(es_event_xpc_connect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_event_xpc_connect_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_event_xpc_connect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xpc_connect_t),
            "::",
            stringify!(service_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_domain_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(es_event_xpc_connect_t),
            "::",
            stringify!(service_domain_type)
        )
    );
}
#[doc = " Union of all possible events that can appear in an es_message_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_events_t {
    #[doc = " Events added before macOS 13.0 use structs directly."]
    pub access: es_event_access_t,
    pub chdir: es_event_chdir_t,
    pub chroot: es_event_chroot_t,
    pub clone: es_event_clone_t,
    pub close: es_event_close_t,
    pub copyfile: es_event_copyfile_t,
    pub create: es_event_create_t,
    pub cs_invalidated: es_event_cs_invalidated_t,
    pub deleteextattr: es_event_deleteextattr_t,
    pub dup: es_event_dup_t,
    pub exchangedata: es_event_exchangedata_t,
    pub exec: es_event_exec_t,
    pub exit: es_event_exit_t,
    pub file_provider_materialize: es_event_file_provider_materialize_t,
    pub file_provider_update: es_event_file_provider_update_t,
    pub fcntl: es_event_fcntl_t,
    pub fork: es_event_fork_t,
    pub fsgetpath: es_event_fsgetpath_t,
    pub get_task: es_event_get_task_t,
    pub get_task_read: es_event_get_task_read_t,
    pub get_task_inspect: es_event_get_task_inspect_t,
    pub get_task_name: es_event_get_task_name_t,
    pub getattrlist: es_event_getattrlist_t,
    pub getextattr: es_event_getextattr_t,
    pub iokit_open: es_event_iokit_open_t,
    pub kextload: es_event_kextload_t,
    pub kextunload: es_event_kextunload_t,
    pub link: es_event_link_t,
    pub listextattr: es_event_listextattr_t,
    pub lookup: es_event_lookup_t,
    pub mmap: es_event_mmap_t,
    pub mount: es_event_mount_t,
    pub mprotect: es_event_mprotect_t,
    pub open: es_event_open_t,
    pub proc_check: es_event_proc_check_t,
    pub proc_suspend_resume: es_event_proc_suspend_resume_t,
    pub pty_close: es_event_pty_close_t,
    pub pty_grant: es_event_pty_grant_t,
    pub readdir: es_event_readdir_t,
    pub readlink: es_event_readlink_t,
    pub remote_thread_create: es_event_remote_thread_create_t,
    pub remount: es_event_remount_t,
    pub rename: es_event_rename_t,
    pub searchfs: es_event_searchfs_t,
    pub setacl: es_event_setacl_t,
    pub setattrlist: es_event_setattrlist_t,
    pub setextattr: es_event_setextattr_t,
    pub setflags: es_event_setflags_t,
    pub setmode: es_event_setmode_t,
    pub setowner: es_event_setowner_t,
    pub settime: es_event_settime_t,
    pub setuid: es_event_setuid_t,
    pub setgid: es_event_setgid_t,
    pub seteuid: es_event_seteuid_t,
    pub setegid: es_event_setegid_t,
    pub setreuid: es_event_setreuid_t,
    pub setregid: es_event_setregid_t,
    pub signal: es_event_signal_t,
    pub stat: es_event_stat_t,
    pub trace: es_event_trace_t,
    pub truncate: es_event_truncate_t,
    pub uipc_bind: es_event_uipc_bind_t,
    pub uipc_connect: es_event_uipc_connect_t,
    pub unlink: es_event_unlink_t,
    pub unmount: es_event_unmount_t,
    pub utimes: es_event_utimes_t,
    pub write: es_event_write_t,
    #[doc = " Events added in macOS 13.0 or later use nonnull pointers."]
    pub authentication: *mut es_event_authentication_t,
    pub xp_malware_detected: *mut es_event_xp_malware_detected_t,
    pub xp_malware_remediated: *mut es_event_xp_malware_remediated_t,
    pub lw_session_login: *mut es_event_lw_session_login_t,
    pub lw_session_logout: *mut es_event_lw_session_logout_t,
    pub lw_session_lock: *mut es_event_lw_session_lock_t,
    pub lw_session_unlock: *mut es_event_lw_session_unlock_t,
    pub screensharing_attach: *mut es_event_screensharing_attach_t,
    pub screensharing_detach: *mut es_event_screensharing_detach_t,
    pub openssh_login: *mut es_event_openssh_login_t,
    pub openssh_logout: *mut es_event_openssh_logout_t,
    pub login_login: *mut es_event_login_login_t,
    pub login_logout: *mut es_event_login_logout_t,
    pub btm_launch_item_add: *mut es_event_btm_launch_item_add_t,
    pub btm_launch_item_remove: *mut es_event_btm_launch_item_remove_t,
    pub profile_add: *mut es_event_profile_add_t,
    pub profile_remove: *mut es_event_profile_remove_t,
    pub su: *mut es_event_su_t,
    pub authorization_petition: *mut es_event_authorization_petition_t,
    pub authorization_judgement: *mut es_event_authorization_judgement_t,
    pub sudo: *mut es_event_sudo_t,
    pub od_group_add: *mut es_event_od_group_add_t,
    pub od_group_remove: *mut es_event_od_group_remove_t,
    pub od_group_set: *mut es_event_od_group_set_t,
    pub od_modify_password: *mut es_event_od_modify_password_t,
    pub od_disable_user: *mut es_event_od_disable_user_t,
    pub od_enable_user: *mut es_event_od_enable_user_t,
    pub od_attribute_value_add: *mut es_event_od_attribute_value_add_t,
    pub od_attribute_value_remove: *mut es_event_od_attribute_value_remove_t,
    pub od_attribute_set: *mut es_event_od_attribute_set_t,
    pub od_create_user: *mut es_event_od_create_user_t,
    pub od_create_group: *mut es_event_od_create_group_t,
    pub od_delete_user: *mut es_event_od_delete_user_t,
    pub od_delete_group: *mut es_event_od_delete_group_t,
    pub xpc_connect: *mut es_event_xpc_connect_t,
}
#[test]
fn bindgen_test_layout_es_events_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_events_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_events_t>(),
        104usize,
        concat!("Size of: ", stringify!(es_events_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_events_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_events_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(chdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(chroot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clone) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(copyfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs_invalidated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(cs_invalidated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deleteextattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(deleteextattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exchangedata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(exchangedata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(exec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_provider_materialize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(file_provider_materialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_provider_update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(file_provider_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcntl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(fcntl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fork) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(fork)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsgetpath) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(fsgetpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_task) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(get_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_task_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(get_task_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_task_inspect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(get_task_inspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_task_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(get_task_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getattrlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(getattrlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getextattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(getextattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iokit_open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(iokit_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kextload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(kextload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kextunload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(kextunload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listextattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(listextattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mprotect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(mprotect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proc_check) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(proc_check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proc_suspend_resume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(proc_suspend_resume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pty_close) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(pty_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pty_grant) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(pty_grant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(readdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readlink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(readlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_thread_create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(remote_thread_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(remount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).searchfs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(searchfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setacl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setattrlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setattrlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setextattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setextattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setflags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setmode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setowner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setowner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(settime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setgid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setgid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seteuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(seteuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setegid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setegid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setreuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setreuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setregid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(setregid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uipc_bind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(uipc_bind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uipc_connect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(uipc_connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unlink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utimes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(utimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(authentication)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xp_malware_detected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(xp_malware_detected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xp_malware_remediated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(xp_malware_remediated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lw_session_login) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(lw_session_login)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lw_session_logout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(lw_session_logout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lw_session_lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(lw_session_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lw_session_unlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(lw_session_unlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screensharing_attach) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(screensharing_attach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screensharing_detach) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(screensharing_detach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openssh_login) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(openssh_login)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openssh_logout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(openssh_logout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).login_login) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(login_login)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).login_logout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(login_logout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btm_launch_item_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(btm_launch_item_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btm_launch_item_remove) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(btm_launch_item_remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(profile_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_remove) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(profile_remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).su) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(su)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorization_petition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(authorization_petition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorization_judgement) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(authorization_judgement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sudo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(sudo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_group_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_group_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_group_remove) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_group_remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_group_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_group_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_modify_password) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_modify_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_disable_user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_disable_user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_enable_user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_enable_user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_attribute_value_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_attribute_value_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_attribute_value_remove) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_attribute_value_remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_attribute_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_attribute_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_create_user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_create_user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_create_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_create_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_delete_user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_delete_user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).od_delete_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(od_delete_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xpc_connect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_events_t),
            "::",
            stringify!(xpc_connect)
        )
    );
}
#[doc = " es_result_t indicates the result of the ES subsystem authorization process\n The result_type field indicates if the result is an es_auth_result_t or a uint32_t (flags)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct es_result_t {
    pub result_type: es_result_type_t,
    pub result: es_result_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_result_t__bindgen_ty_1 {
    pub auth: es_auth_result_t,
    pub flags: u32,
    pub reserved: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_es_result_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_result_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_result_t__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(es_result_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_result_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(es_result_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_result_t__bindgen_ty_1),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_result_t__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_result_t__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_es_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_result_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_result_t>(),
        36usize,
        concat!("Size of: ", stringify!(es_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_result_t>(),
        4usize,
        concat!("Alignment of ", stringify!(es_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_result_t),
            "::",
            stringify!(result_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(es_result_t),
            "::",
            stringify!(result)
        )
    );
}
#[doc = " @brief es_message_t is the top level datatype that encodes information sent\n from the ES subsystem to its clients.  Each security event being processed\n by the ES subsystem will be encoded in an es_message_t.  A message can be an\n authorization request or a notification of an event that has already taken\n place.\n\n @field version Indicates the message version; some fields are not available\n        and must not be accessed unless the message version is equal to or\n        higher than the message version at which the field was introduced.\n @field time The time at which the event was generated.\n @field mach_time The Mach absolute time at which the event was generated.\n @field deadline The Mach absolute time before which an auth event must\n        be responded to. If a client fails to respond to auth events prior to the `deadline`,\n        the client will be killed.\n        Each message can contain its own unique deadline, and some deadlines\n        can vary substantially. Clients must take care to inspect the deadline\n        value of each message to know how much time is allotted for processing.\n @field process Describes the process that took the action.\n @field seq_num Per-client, per-event-type sequence number that can be\n        inspected to detect whether the kernel had to drop events for this\n        client.  When no events are dropped for this client, seq_num\n        increments by 1 for every message of that event type.  When events\n        have been dropped, the difference between the last seen sequence\n        number of that event type plus 1 and seq_num of the received message\n        indicates the number of events that had to be dropped.\n        Dropped events generally indicate that more events were generated in\n        the kernel than the client was able to handle.\n        Field available only if message version >= 2.\n        @see global_seq_num\n @field action_type Indicates if the action field is an auth or notify action.\n @field action For auth events, contains the opaque auth ID that must be\n        supplied when responding to the event.  For notify events, describes\n        the result of the action.\n @field event_type Indicates which event struct is defined in the event union.\n @field event Contains data specific to the event type.\n @field thread Describes the thread that took the action.  May be NULL when\n        thread is not applicable, for example for trace events that describe\n        the traced process calling ptrace(PT_TRACE_ME) or for cs invalidated\n        events that are a result of another process calling\n        csops(CS_OPS_MARKINVALID).\n        Field available only if message version >= 4.\n @field global_seq_num Per-client sequence number that can be inspected to\n        detect whether the kernel had to drop events for this client. When no\n        events are dropped for this client, global_seq_num increments by 1 for\n        every message. When events have been dropped, the difference between\n        the last seen global sequence number and the global_seq_num of the\n        received message indicates the number of events that had to be dropped.\n        Dropped events generally indicate that more events were generated in\n        the kernel than the client was able to handle.\n        Field available only if message version >= 4.\n        @see seq_num\n @field opaque Opaque data that must not be accessed directly.\n\n @note For events that can be authorized there are unique NOTIFY and AUTH\n event types for the same event data, eg: event.exec is the correct union\n label for both ES_EVENT_TYPE_AUTH_EXEC and ES_EVENT_TYPE_NOTIFY_EXEC event\n types.\n\n @note For fields marked only available in specific message versions, all\n access must be guarded at runtime by checking the value of the message\n version field, e.g.\n ```\n if (msg->version >= 2) {\n     acl = msg->event.create.acl;\n }\n ```\n\n @note Fields using Mach time are in the resolution matching the ES client's\n architecture.  This means they can be compared to mach_absolute_time() and\n converted to nanoseconds with the help of mach_timebase_info().  Further\n note that on Apple silicon, x86_64 clients running under Rosetta 2 will see\n Mach times in a different resolution than native arm64 clients.  For more\n information on differences regarding Mach time on Apple silicon and Intel-based\n Mac computers, see \"Addressing Architectural Differences in Your macOS Code\":\n https://developer.apple.com/documentation/apple_silicon/addressing_architectural_differences_in_your_macos_code"]
#[repr(C)]
pub struct es_message_t {
    pub version: u32,
    pub time: timespec,
    pub mach_time: u64,
    pub deadline: u64,
    pub process: *mut es_process_t,
    pub seq_num: u64,
    pub action_type: es_action_type_t,
    pub action: es_message_t__bindgen_ty_1,
    pub event_type: es_event_type_t,
    pub event: es_events_t,
    pub thread: *mut es_thread_t,
    pub global_seq_num: u64,
    pub opaque: __IncompleteArrayField<u64>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union es_message_t__bindgen_ty_1 {
    pub auth: es_event_id_t,
    pub notify: es_result_t,
}
#[test]
fn bindgen_test_layout_es_message_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<es_message_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_message_t__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(es_message_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<es_message_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(es_message_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t__bindgen_ty_1),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t__bindgen_ty_1),
            "::",
            stringify!(notify)
        )
    );
}
#[test]
fn bindgen_test_layout_es_message_t() {
    const UNINIT: ::std::mem::MaybeUninit<es_message_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<es_message_t>(),
        224usize,
        concat!("Size of: ", stringify!(es_message_t))
    );
    assert_eq!(
        ::std::mem::align_of::<es_message_t>(),
        8usize,
        concat!("Alignment of ", stringify!(es_message_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mach_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(mach_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadline) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(seq_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(action_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_seq_num) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(global_seq_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(es_message_t),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    #[doc = " Calculate the size of an es_message_t.\n\n @warning This function MUST NOT be used in conjunction with attempting to copy an es_message_t (e.g.\n by using the reported size in order to `malloc(3)` a buffer, and `memcpy(3)` an existing es_message_t\n into that buffer). Doing so will result in use-after-free bugs.\n\n @deprecated Please use `es_retain_message` to retain an es_message_t.\n\n @param msg The message for which the size will be calculated\n @return Size of the message"]
    pub fn es_message_size(msg: *const es_message_t) -> usize;
}
extern "C" {
    #[doc = " Retains an es_message_t, returning a non-const pointer to the given es_message_t for compatibility with\n existing code.\n\n @warning It is invalid to attempt to write to the returned es_message_t, despite being non-const, and\n doing so will result in a crash.\n\n @deprecated Use es_retain_message to retain a message.\n\n @param msg The message to be retained\n @return non-const pointer to the retained es_message_t.\n\n @brief The caller must release the memory with `es_free_message`"]
    pub fn es_copy_message(msg: *const es_message_t) -> *mut es_message_t;
}
extern "C" {
    #[doc = " Releases the memory associated with the given es_message_t that was retained via `es_copy_message`\n\n @deprecated Use `es_release_message` to release a message.\n\n @param msg The message to be released"]
    pub fn es_free_message(msg: *mut es_message_t);
}
extern "C" {
    #[doc = " Retains the given es_message_t, extending its lifetime until released with `es_release_message`.\n\n @param msg The message to be retained\n\n @note It is necessary to retain a message when the es_message_t provided in the event handler block of\n `es_new_client` will be processed asynchronously."]
    pub fn es_retain_message(msg: *const es_message_t);
}
extern "C" {
    #[doc = " Releases the given es_message_t that was previously retained with `es_retain_message`\n\n @param msg The message to be released"]
    pub fn es_release_message(msg: *const es_message_t);
}
extern "C" {
    #[doc = " Get the number of arguments in a message containing an es_event_exec_t\n @param event The es_event_exec_t being inspected\n @return The number of arguments"]
    pub fn es_exec_arg_count(event: *const es_event_exec_t) -> u32;
}
extern "C" {
    #[doc = " Get the number of environment variables in a message containing an es_event_exec_t\n @param event The es_event_exec_t being inspected\n @return The number of environment variables"]
    pub fn es_exec_env_count(event: *const es_event_exec_t) -> u32;
}
extern "C" {
    #[doc = " Get the number of file descriptors in a message containing an es_event_exec_t\n @param event The es_event_exec_t being inspected\n @return The number of file descriptors"]
    pub fn es_exec_fd_count(event: *const es_event_exec_t) -> u32;
}
extern "C" {
    #[doc = " Get the argument at the specified position in the message containing an es_event_exec_t\n @param event The es_event_exec_t being inspected\n @param index Index of the argument to retrieve (starts from 0)\n @return  es_string_token_t containing a pointer to the argument and its length.\n          This is a zero-allocation operation. The returned pointer must not outlive exec_event.\n @brief Reading an an argument where `index` >= `es_exec_arg_count()` is undefined"]
    pub fn es_exec_arg(event: *const es_event_exec_t, index: u32) -> es_string_token_t;
}
extern "C" {
    #[doc = " Get the environment variable at the specified position in the message containing an es_event_exec_t\n @param event The es_event_exec_t being inspected\n @param index Index of the environment variable to retrieve (starts from 0)\n @return  es_string_token_t containing a pointer to the environment variable and its length.\n          This is zero-allocation operation. The returned pointer must not outlive exec_event.\n @brief Reading an an env where `index` >= `es_exec_env_count()` is undefined"]
    pub fn es_exec_env(event: *const es_event_exec_t, index: u32) -> es_string_token_t;
}
extern "C" {
    #[doc = " Get the file descriptor at the specified position in the message containing an es_event_exec_t\n @param event The es_event_exec_t being inspected\n @param index Index of the file descriptor to retrieve (starts from 0)\n @return Pointer to es_fd_t describing the file descriptor.\n         This is zero-allocation operation. The returned pointer must not outlive exec_event.\n @note Reading an fd where `index` >= `es_exec_fd_count()` is undefined"]
    pub fn es_exec_fd(event: *const es_event_exec_t, index: u32) -> *const es_fd_t;
}
#[doc = " This typedef is no longer used, but exists for API backwards compatibility."]
pub type es_statfs_t = statfs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct es_client_s {
    _unused: [u8; 0],
}
#[doc = " es_client_t is an opaque type that stores the endpoint security client state"]
pub type es_client_t = es_client_s;
extern "C" {
    #[doc = " Subscribe to some set of events\n @param client The client that will be subscribing\n @param events Array of es_event_type_t to subscribe to\n @param event_count Count of es_event_type_t in `events`\n @return es_return_t indicating success or error\n\n @note Subscribing to new event types does not remove previous subscriptions.\n\n @note Subscribing to events is not optional for clients that have opted into\n       early boot mode (see NSEndpointSecurityEarlyBoot in EndpointSecurity(7)).\n       Early boot clients that fail to subscribe to at least one event type will\n       cause early boot to time out, resulting in a bad user experience and\n       risking watchdog timeout panics."]
    pub fn es_subscribe(
        client: *mut es_client_t,
        events: *const es_event_type_t,
        event_count: u32,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " Unsubscribe from some set of events\n @param client The client that will be unsubscribing\n @param events Array of es_event_type_t to unsubscribe from\n @param event_count Count of es_event_type_t in `events`\n @return es_return_t indicating success or error\n @note Events not included in the given `events` array that were previously subscribed to will continue to be subscribed to"]
    pub fn es_unsubscribe(
        client: *mut es_client_t,
        events: *const es_event_type_t,
        event_count: u32,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " Unsubscribe from all events\n @param client The client that will be unsubscribing\n @return es_return_t indicating success or error"]
    pub fn es_unsubscribe_all(client: *mut es_client_t) -> es_return_t;
}
extern "C" {
    #[doc = " List subscriptions\n @param client The client for which subscriptions will be listed\n @param count Out param that reports the number of subscriptions written\n @param subscriptions  Out param for pointer to subscription data\n @return es_return_t indicating success or error\n @brief The caller takes ownership of the memory at `*subscriptions` and must free it"]
    pub fn es_subscriptions(
        client: *mut es_client_t,
        count: *mut usize,
        subscriptions: *mut *mut es_event_type_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " Respond to an auth event that requires an es_auth_result_t response\n @param client The client that produced the event\n @param message The message being responded to\n @param result A result indicating the action the ES subsystem should take\n @param cache Indicates if this result should be cached.  The specific\n        caching semantics depend on es_event_type_t.  Cache key is generally\n        the involved files, with modifications to those files invalidating\n        the cache entry.  A cache hit leads to no AUTH event being produced,\n        while still producing a NOTIFY event normally.\n        The cache argument is ignored for events that do not support caching.\n @return es_respond_result_t indicating success or an error\n @brief Some events must be responded to with `es_respond_flags_result`. Responding to flags events with this function will fail."]
    pub fn es_respond_auth_result(
        client: *mut es_client_t,
        message: *const es_message_t,
        result: es_auth_result_t,
        cache: bool,
    ) -> es_respond_result_t;
}
extern "C" {
    #[doc = " Respond to an auth event that requires an uint32_t flags response\n @param client The client that produced the event\n @param message The message being responded to\n @param authorized_flags A flags value that will mask the flags in event being\n        responded to; pass 0 to deny and UINT32_MAX to allow regardless of what\n        flags are set on the event.\n @param cache Indicates if this result should be cached.  The specific\n        caching semantics depend on es_event_type_t.  Cache key is generally\n        the involved files, with modifications to those files invalidating\n        the cache entry.  A cache hit leads to no AUTH event being produced,\n        while still producing a NOTIFY event normally.\n        The cache argument is ignored for events that do not support caching.\n @return es_respond_result_t indicating success or an error\n @brief Some events must be responded to with `es_respond_auth_result`. Responding to auth events with the function will fail.\n @note Enabling caching caches authorized_flags.  Subsequent cache hits\n       will result in the event being allowed only if the flags of the\n       event are a subset of the flags in authorized_flags, and denied\n       otherwise.  As a result, UINT32_MAX should be passed for\n       authorized_flags, unless denying events with certain flags is\n       intentional.  A common mistake is passing the flags from the\n       event, which together with caching may result in subsequent\n       events getting unintentionally denied if they have flags set\n       that were not set in the cached authorized_flags."]
    pub fn es_respond_flags_result(
        client: *mut es_client_t,
        message: *const es_message_t,
        authorized_flags: u32,
        cache: bool,
    ) -> es_respond_result_t;
}
extern "C" {
    #[doc = " @brief Suppress all events from the process described by the given `audit_token`\n\n @param client The client for which events will be suppressed\n @param audit_token The audit token of the process for which events will be suppressed\n\n @return es_return_t indicating success or error\n\n @see es_mute_process_events"]
    pub fn es_mute_process(
        client: *mut es_client_t,
        audit_token: *const audit_token_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Suppress a subset of events from the process described by the given `audit_token`\n\n @param client The client for which events will be suppressed\n @param audit_token The audit token of the process for which events will be suppressed\n @param events Array of event types for which the audit_token should be muted.\n @param event_count The number of items in the `events` array.\n\n @return es_return_t A value indicating whether or not the process was successfully muted.\n\n @see es_mute_process"]
    pub fn es_mute_process_events(
        client: *mut es_client_t,
        audit_token: *const audit_token_t,
        events: *const es_event_type_t,
        event_count: usize,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Unmute a process for all event types\n\n @param client The client for which the process will be unmuted\n @param audit_token The audit token of the process to be unmuted\n\n @return es_return_t indicating success or error\n\n @see es_unmute_process_events"]
    pub fn es_unmute_process(
        client: *mut es_client_t,
        audit_token: *const audit_token_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Unmute a process for a subset of event types.\n\n @param client The client for which events will be unmuted\n @param audit_token The audit token of the process for which events will be unmuted\n @param events Array of event types to unmute for the process\n @param event_count The number of items in the `events` array.\n\n @return es_return_t A value indicating whether or not the process was successfully unmuted.\n\n @see es_unmute_path"]
    pub fn es_unmute_process_events(
        client: *mut es_client_t,
        audit_token: *const audit_token_t,
        events: *const es_event_type_t,
        event_count: usize,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " List muted processes\n @param client The client for which muted processes will be listed\n @param count Out param that reports the number of audit tokens written\n @param audit_tokens  Out param for pointer to audit_token data\n @return es_return_t indicating success or error\n @brief The caller takes ownership of the memory at `*audit_tokens` and must free it.\n        If there are no muted processes and the call completes successfully,\n        `*count` is set to 0 and `*audit_token` is set to NULL.\n @note The audit tokens are returned in the same state as they were passed to\n       `es_mute_process` and may not accurately reflect the current state of the\n       respective processes."]
    pub fn es_muted_processes(
        client: *mut es_client_t,
        count: *mut usize,
        audit_tokens: *mut *mut audit_token_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Retrieve a list of all muted processes.\n\n @param client The es_client_t for which the muted processes will be retrieved.\n @param muted_processes OUT param the will contain newly created memory describing the set of\n        muted processes. This memory must be deleted using `es_release_muted_processes`.\n\n @return es_return_t A value indicating whether or not the list of muted processes were\n         successfully retrieved.\n\n @see es_release_muted_processes"]
    pub fn es_muted_processes_events(
        client: *mut es_client_t,
        muted_processes: *mut *mut es_muted_processes_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Delete a set of muted processes obtained from `es_muted_processes_events`, freeing resources.\n\n @param muted_processes A set of muted processes to delete.\n\n @see es_muted_processes_all_events"]
    pub fn es_release_muted_processes(muted_processes: *mut es_muted_processes_t);
}
extern "C" {
    #[doc = " @brief Suppress all events matching a path.\n\n @param client The es_client_t for which the path will be muted.\n @param path The path to mute.\n @param type Describes the type of the `path` parameter.\n\n @return es_return_t A value indicating whether or not the path was successfully muted.\n\n @note Path-based muting applies to the real and potentially firmlinked path\n       of a file as seen by VFS, and as available from fcntl(2) F_GETPATH.\n       No special provisions are made for files with multiple (\"hard\") links,\n       or for symbolic links.\n       In particular, when using inverted target path muting to monitor a\n       particular path for writing, you will need to check if the file(s) of\n       interest are also reachable via additional hard links outside of the\n       paths you are observing.\n\n @see es_mute_path_events\n @discussion When using the path types ES_MUTE_PATH_TYPE_TARGET_PREFIX and ES_MUTE_PATH_TYPE_TARGET_LITERAL Not all events are supported.\n Furthermore the interpretation of target path is contextual.\n For events with more than one target path (such as exchangedata) the behavior depends on the mute inversion state\n   Under normal muting the event is suppressed only if ALL paths are muted\n   When target path muting is inverted the event is selected if ANY target path is muted\n For example a rename will be suppressed if and only if both the source path and destination path are muted.\n Supported events are listed below. For each event the target path is defined as:\n\n EXEC: The file being executed\n OPEN: The file being opened\n MMAP: The file being memory mapped\n RENAME: Both the source and destination path.\n SIGNAL: The path of the process being signalled\n UNLINK: The file being unlinked\n CLOSE: The file being closed\n CREATE: The path to the file that will be created or replaced\n GET_TASK: The path of the process for which the task port is being retrieved\n LINK: Both the source and destination path\n SETATTRLIST: The file for which the attributes are being set\n SETEXTATTR: The file for which the extended attributes are being set\n SETFLAGS: The file for which flags are being set\n SETMODE: The file for which the mode is being set\n SETOWNER: The file for which the owner is being set\n WRITE: The file being written to\n READLINK: The symbolic link being resolved\n TRUNCATE: The file being truncated\n CHDIR: The new working directory\n GETATTRLIST: The file for which the attribute list is being retrieved\n STAT: The file for which the stat is being retrieved\n ACCESS: The file for which access is being tested\n CHROOT: The file which will become the new root\n UTIMES: The file for which times are being set\n CLONE: Both the source file and target path\n FCNTL: The file under file control\n GETEXTATTR The file for which extended attributes are being retrieved\n LISTEXTATTR The file for which extended attributes are being listed\n READDIR The directory for whose contents will be read\n DELETEEXTATTR The file for which extended attribues will be deleted\n DUP: The file being duplicated\n UIPC_BIND: The path to the unix socket that will be created\n UIPC_CONNECT: The file that the unix socket being connected is bound to\n EXCHANGEDATA: The path of both file1 and file2\n SETACL: The file for which ACLs are being set\n PROC_CHECK: The path of the process against which access is being checked\n SEARCHFS: The path of the volume which will be searched\n PROC_SUSPEND_RESUME: The path of the process being suspended or resumed\n GET_TASK_NAME: The path of the process for which the task name port will be retrieved\n TRACE: The path of the process that will be attached to\n REMOTE_THREAD_CREATE: The path of the process in which the new thread is created\n GET_TASK_READ: The path of the process for which the task read port will be retrieved\n GET_TASK_INSPECT: The path of the process for which the task inspect port will be retrieved\n COPYFILE: The path to the source file and the path to either the new file to be created or the existing file to be overwritten"]
    pub fn es_mute_path(
        client: *mut es_client_t,
        path: *const ::std::os::raw::c_char,
        type_: es_mute_path_type_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Suppress a subset of events matching a path.\n\n @param client The es_client_t for which the path will be muted.\n @param path The path to mute.\n @param type Describes the type of the `path` parameter, either a prefix path or literal path.\n @param events Array of event types for which the path should be muted.\n @param event_count The number of items in the `events` array.\n\n @return es_return_t A value indicating whether or not the path was successfully muted.\n\n @see es_mute_path\n @discussion when using ES_MUTE_PATH_TYPE_TARGET_PREFIX and ES_MUTE_PATH_TYPE_TARGET_LITERAL not all events are supported.\n Target muting a path for an event type that does not support target muting is a no-op.\n If at least one event type was muted for a target path then ES_RETURN_SUCCESS is returned.\n If all specified event types do not support target muting ES_RETURN_ERROR is returned.\n See es_mute_path for the list of events that support target path muting."]
    pub fn es_mute_path_events(
        client: *mut es_client_t,
        path: *const ::std::os::raw::c_char,
        type_: es_mute_path_type_t,
        events: *const es_event_type_t,
        event_count: usize,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " Suppress events matching a path prefix\n\n @deprecated Please use `es_mute_path` or `es_mute_path_events`\n\n @param client The client for which events will be suppressed\n @param path_prefix The path against which suppressed executables must prefix match\n @return es_return_t indicating success or error"]
    pub fn es_mute_path_prefix(
        client: *mut es_client_t,
        path_prefix: *const ::std::os::raw::c_char,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " Suppress events matching a path literal\n\n @deprecated Please use `es_mute_path` or `es_mute_path_events`\n\n @param client The client for which events will be suppressed\n @param path_literal The path against which suppressed executables must match exactly\n @return es_return_t indicating success or error\n\n @see es_mute_path\n @see es_mute_path_events"]
    pub fn es_mute_path_literal(
        client: *mut es_client_t,
        path_literal: *const ::std::os::raw::c_char,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " Unmute all paths\n @param client The client for which all currently muted paths will be unmuted\n @return es_return_t indicating success or error\n\n @note Only unmutes executable paths. To unmute target paths see: `es_unmute_all_target_paths`."]
    pub fn es_unmute_all_paths(client: *mut es_client_t) -> es_return_t;
}
extern "C" {
    #[doc = " Unmute all target paths\n @param client The client for which all currently muted target paths will be unmuted\n @return es_return_t indicating success or error"]
    pub fn es_unmute_all_target_paths(client: *mut es_client_t) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Unmute a path for all event types.\n\n @param client The es_client_t for which the path will be unmuted.\n @param path The path to unmute.\n @param type Describes the type of the `path` parameter, either a prefix path or literal path.\n\n @return es_return_t A value indicating whether or not the path was successfully unmuted.\n\n @note Muting and unmuting operations logically work on a set of (path_type, path, es_event_type_t) tuples\n Subtracting an element from the set that is not present has no effect\n For example if `(literal, /foo/bar/, *)` is muted\n Then `(prefix, /foo, *)` is unmuted the mute set is still:\n `(literal, /foo/bar, *)`.\n Prefixes only apply to mute evaluation not to modifications of the mute set.\n\n @see es_unmute_path_events"]
    pub fn es_unmute_path(
        client: *mut es_client_t,
        path: *const ::std::os::raw::c_char,
        type_: es_mute_path_type_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Unmute a path for a subset of event types.\n\n @param client The es_client_t for which the path will be unmuted.\n @param path The path to unmute.\n @param type Describes the type of the `path` parameter, either a prefix path or literal path.\n @param events Array of event types for which the path should be unmuted.\n @param event_count The number of items in the `events` array.\n\n @return es_return_t A value indicating whether or not the path was successfully unmuted.\n\n @see es_unmute_path"]
    pub fn es_unmute_path_events(
        client: *mut es_client_t,
        path: *const ::std::os::raw::c_char,
        type_: es_mute_path_type_t,
        events: *const es_event_type_t,
        event_count: usize,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Retrieve a list of all muted paths.\n\n @param client The es_client_t for which the muted paths will be retrieved.\n @param muted_paths OUT param the will contain newly created memory describing the set of\n        muted paths. This memory must be deleted using `es_release_muted_paths`.\n\n @return es_return_t A value indicating whether or not the list of muted paths were successfully retrieved.\n\n @see es_release_muted_paths"]
    pub fn es_muted_paths_events(
        client: *mut es_client_t,
        muted_paths: *mut *mut es_muted_paths_t,
    ) -> es_return_t;
}
extern "C" {
    #[doc = " @brief Delete a set of muted paths obtained from `es_muted_paths_events`, freeing resources.\n\n @param muted_paths A set of muted paths to delete.\n\n @see es_muted_paths_events"]
    pub fn es_release_muted_paths(muted_paths: *mut es_muted_paths_t);
}
extern "C" {
    pub fn es_invert_muting(
        client: *mut es_client_t,
        mute_type: es_mute_inversion_type_t,
    ) -> es_return_t;
}
extern "C" {
    pub fn es_muting_inverted(
        client: *mut es_client_t,
        mute_type: es_mute_inversion_type_t,
    ) -> es_mute_inverted_return_t;
}
extern "C" {
    #[doc = " Clear all cached results for all clients.\n @param client that will perform the request\n @return es_clear_cache_result_t value indicating success or an error\n @discussion This functions clears the shared cache for all ES clients and is hence rate limited.\n             If es_clear_cache is called too frequently it will return ES_CLEAR_CACHE_RESULT_ERR_THROTTLE\n             It is permissible to pass any valid es_client_t object created by `es_new_client`"]
    pub fn es_clear_cache(client: *mut es_client_t) -> es_clear_cache_result_t;
}
#[doc = " es_handler_block_t The type of block that will be invoked to handled messages from the ES subsystem\n The es_client_t is a handle to the client being sent the event. It must be passed to any \"respond\" functions\n The es_message_t is the message that must be handled"]
pub type es_handler_block_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " Initialise a new es_client_t and connect to the ES subsystem\n @param client Out param. On success this will be set to point to the newly allocated es_client_t.\n @param handler The handler block that will be run on all messages sent to this client\n @return es_new_client_result_t indicating success or a specific error.\n @discussion Messages are handled strictly serially and in the order they are delivered.\n             Returning control from the handler causes the next available message to be dequeued.\n             Messages can be responded to out of order by returning control before calling es_respond_*.\n             The es_message_t is only guaranteed to live as long as the scope it is passed into.\n             The memory for the given es_message_t is NOT owned by clients and it must not be freed.\n             For out of order responding the handler must retain the message with es_retain_message.\n             Callers are required to be entitled with com.apple.developer.endpoint-security.client.\n             The application calling this interface must also be approved by users via Transparency, Consent & Control\n             (TCC) mechanisms using the Privacy Preferences pane and adding the application to Full Disk Access.\n             When a new client is successfully created, all cached results are automatically cleared.\n\n @note When a new client is initialized, there will be a set of paths and a subset of `es_event_type_t` events that are\n       automatically muted by default. Generally, most AUTH event variants are muted but NOTIFY event variants will\n       still be sent to the client. The set of paths muted by default are ones that can have an extremely negative impact to\n       end users if their AUTH events are not allowed in a timely manner (for example, executable paths for processes\n       that are monitored by the watchdogd daemon). It is important to understand that this list is *not* exhaustive and\n       developers using the EndpointSecurity framework can still interfere with critical system components and must use\n       caution to limit user impact. The set of default muted paths and event types may change across macOS releases.\n       It is possible to both inspect and unmute the set of default muted paths and associated event types using the\n       appropriate mute-related API, however it is not recommended to unmute these items.\n\n @note The only supported way to check if an application is properly TCC authorized for Full Disk Access\n       is to call es_new_client and handling ES_NEW_CLIENT_RESULT_ERR_NOT_PERMITTED in a way appropriate\n       to your application.  Most applications will want to ask the user for TCC authorization when\n       es_new_client returns ES_NEW_CLIENT_RESULT_ERR_NOT_PERMITTED.\n       To direct the user to the Full Disk Access section in System Settings, applications can use the following URLs:\n       `x-apple.systempreferences:com.apple.settings.PrivacySecurity.extension?Privacy_AllFiles` (macOS 13 and later)\n       `x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles` (until macOS 12)\n       Applications are advised to use the new URL in macOS 13 as the old one may stop working in a future release.\n\n @see es_retain_message\n @see es_release_message\n @see es_new_client_result_t\n @see es_muted_paths_events\n @see es_unmute_path_events"]
    pub fn es_new_client(
        client: *mut *mut es_client_t,
        handler: es_handler_block_t,
    ) -> es_new_client_result_t;
}
extern "C" {
    #[doc = " Destroy an es_client_t, freeing resources and disconnecting from the ES subsystem\n @param client The client to be destroyed\n @return  ES_RETURN_SUCCESS indicates all resources were freed.\n          ES_RETURN_ERROR indicates an error occurred during shutdown and resources were leaked.\n @note Must be called from the same thread that originally called `es_new_client`."]
    pub fn es_delete_client(client: *mut es_client_t) -> es_return_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
